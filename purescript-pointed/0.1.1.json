{"uploader":"vladciobanu","packageMeta":{"repository":{"url":"https://github.com/vladciobanu/purescript-pointed","type":"git"},"ignore":["**/.*","node_modules","bower_components","output"],"dependencies":{"purescript-maybe":"^v4.0.1","purescript-foldable-traversable":"^v4.1.1","purescript-bifunctors":"^v4.0.0","purescript-generics-rep":"^v6.1.1","purescript-lists":"^v5.4.1"},"name":"purescript-pointed","license":["MIT"]},"tagTime":"2020-10-12T13:48:27+0000","modules":[{"reExports":[],"name":"Data.Pointed.Can","comments":"This module defines the type `Can`, along with instances and functions that\nhelp use this type. Generally, `Can` is used when the data is more vague\nthan simply using `Either a b` or `Tuple a b`, i.e. when either `a` or `b`\nmight be missing or be present independently.\n","declarations":[{"children":[{"comments":null,"title":"Non","info":{"arguments":[],"declType":"dataConstructor"},"sourceSpan":null},{"comments":null,"title":"One","info":{"arguments":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"declType":"dataConstructor"},"sourceSpan":null},{"comments":null,"title":"Eno","info":{"arguments":[{"annotation":[],"tag":"TypeVar","contents":"b"}],"declType":"dataConstructor"},"sourceSpan":null},{"comments":null,"title":"Two","info":{"arguments":[{"annotation":[],"tag":"TypeVar","contents":"a"},{"annotation":[],"tag":"TypeVar","contents":"b"}],"declType":"dataConstructor"},"sourceSpan":null},{"comments":"`Can` values can be compared. Note that they are only equal if they are\nprecisely equal.\n\n```purescript\n> (One \"hello\" :: Can String Int) == (Two \"hello\" 42 :: Can String Int)\nfalse\n```\n","title":"eqCan","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Eq"],"Eq"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null},{"constraintAnn":[],"constraintClass":[["Data","Eq"],"Eq"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"b"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Eq"],"Eq"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}},"sourceSpan":{"start":[38,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[38,54]}},{"comments":null,"title":"ordCan","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Ord"],"Ord"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null},{"constraintAnn":[],"constraintClass":[["Data","Ord"],"Ord"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"b"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Ord"],"Ord"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}},"sourceSpan":{"start":[40,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[40,58]}},{"comments":null,"title":"genericCan","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Generic","Rep"],"Generic"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeWildcard","contents":null}]}},"sourceSpan":{"start":[42,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[42,50]}},{"comments":null,"title":"functorCan","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Functor"],"Functor"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[44,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[44,46]}},{"comments":"The `Semigroup` instance will never lose information and requires both\n`a` and `b` to have `Semigroup` instances:\n\n```purescript\n> (One \"hello\" :: Can String String) <> Two \"world\" \"42\"\nTwo \"helloworld\" \"42\"\n```\n","title":"semigroupCan","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null},{"constraintAnn":[],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"b"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Semigroup"],"Semigroup"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}},"sourceSpan":{"start":[53,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[65,39]}},{"comments":null,"title":"monoidCan","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null},{"constraintAnn":[],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"b"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Monoid"],"Monoid"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}},"sourceSpan":{"start":[67,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[68,15]}},{"comments":"```purescript\n> bimap show (_ + 10) (Two 42 32)\nTwo \"42\" 42\n```\n","title":"bifunctorCan","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Bifunctor"],"Bifunctor"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]}]}},"sourceSpan":{"start":[74,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[79,31]}},{"comments":null,"title":"biApplyCan","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Biapply"],"Biapply"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]}]}},"sourceSpan":{"start":[81,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[86,28]}},{"comments":null,"title":"biApplicativeCan","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Biapplicative"],"Biapplicative"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]}]}},"sourceSpan":{"start":[88,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[89,15]}},{"comments":null,"title":"bifoldableCan","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Bifoldable"],"Bifoldable"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]}]}},"sourceSpan":{"start":[91,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[99,39]}},{"comments":null,"title":"bitraversableCan","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Bitraversable"],"Bitraversable"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]}]}},"sourceSpan":{"start":[101,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[108,33]}},{"comments":null,"title":"applyCan","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Apply"],"Apply"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[110,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[120,43]}},{"comments":null,"title":"applicativeCan","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Applicative"],"Applicative"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[122,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[123,13]}},{"comments":null,"title":"bindCan","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Bind"],"Bind"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[125,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[134,32]}},{"comments":null,"title":"monadCan","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Monad"],"Monad"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[136,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[136,50]}},{"comments":null,"title":"foldableCan","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Foldable"],"Foldable"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[138,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[141,31]}},{"comments":null,"title":"traversableCan","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Traversable"],"Traversable"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[143,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[145,29]}}],"comments":"`Can a b` can hold either no values, an `a`, a `b`, or both an `a` and\na `b`. The type is isomorphic with `Maybe (Either (Either a b) (Tuple a b))`.\n","title":"Can","info":{"declType":"data","dataDeclType":"data","typeArguments":[["a",null],["b",null]]},"sourceSpan":{"start":[25,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[29,12]}},{"children":[],"comments":"Constructs a `Can` given an isomorphic representation. Note that this is\nthe precise inverse of `toRepr`.\n\n```purescript\n> fromRepr Nothing :: Can String Int\nNon\n\n> fromRepr (Just (Left (Left \"hello\"))) :: Can String Int\nOne \"hello\"\n\n> fromRepr (Just (Left (Right 42))) :: Can String Int\nEno 42\n\n> fromRepr (Just (Right (Tuple \"hello\" 42))) :: Can String Int\nTwo \"hello\" 42\n```\n","title":"fromRepr","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Either"],"Either"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Either"],"Either"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},null]},null]}},"sourceSpan":{"start":[163,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[163,75]}},{"children":[],"comments":"Destructs a `Can` to its isomorphic representation. Note that this is\nthe precise inverse of `fromRepr`.\n\n```purescript\n> toRepr (Non :: Can String Int)\nNothing\n\n> toRepr (One \"hello\" :: Can String Int)\nJust (Left (Left \"hello\"))\n\n> toRepr (Eno 42 :: Can String Int)\nJust (Left (Right 42))\n\n> toRepr Two \"hello\" 42\nJust (Right (Tuple \"hello\" 42))\n```\n","title":"toRepr","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Either"],"Either"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Either"],"Either"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}}]}]},null]},null]}},"sourceSpan":{"start":[186,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[186,73]}},{"children":[],"comments":"Construct a `Can` from a pair of `Maybe`s.\n\n```purescript\n> fromMaybe Nothing Nothing :: Can String Int\nNon\n\n> fromMaybe (Just \"hello\") Nothing :: Can String Int\nOne \"hello\"\n\n> fromMaybe Nothing (Just 42) :: Can String Int\nEno 42\n\n> fromMaybe (Just \"hello\") (Just 42) :: Can String Int\nTwo \"hello\" 42\n```\n","title":"fromMaybe","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}]},null]},null]}},"sourceSpan":{"start":[208,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[208,55]}},{"children":[],"comments":"`Can` catamorphism (fold). Takes an input for each possible constructor and\ntranslates it to `c`.\n\nFor example, we can go from some `c :: Can a b` to a\n`Maybe (Either (Either a b) (Tuple a b))` using:\n\n```purescript\n> can Nothing (Left <<< Left) (Left <<< Right) (\\a b -> Right (Tuple a b)) (Non :: Can String Int)\nNothing\n\n> can Nothing (Left <<< Left) (Left <<< Right) (\\a b -> Right (Tuple a b)) (One \"hello\" :: Can String Int)\nJust (Left (Left \"hello\"))\n\n> can Nothing (Left <<< Left) (Left <<< Right) (\\a b -> Right (Tuple a b)) (Eno 42 :: Can String Int)\nJust (Left (Right 42))\n\n> can Nothing (Left <<< Left) (Left <<< Right) (\\a b -> Right (Tuple a b)) (Two \"hello\" 42 :: Can String Int)\nJust (Right (Tuple \"hello\" 42))\n```\n","title":"can","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"c"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[234,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[234,80]}},{"children":[],"comments":"Grabs an `a` if it exists, otherwise returns nothing. Note that this\nfunction grabs an `a` from either the `One` or the `Two` constructors.\n\n```purescript\n> first (Non :: Can String Int)\nNothing\n\n> first (One \"hello\" :: Can String Int)\nJust \"hello\"\n\n> first (Eno 42 :: Can String Int)\nNothing\n\n> first (Two \"hello\" 42)\nJust \"hello\"\n```\n","title":"first","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},null]},null]}},"sourceSpan":{"start":[257,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[257,40]}},{"children":[],"comments":"Grabs a `b` if it exists, otherwise returns nothing. Note that this\nfunction grabs a `b` from either the `Eno` or the `Two` constructors.\n\n```purescript\n> second (Non :: Can String Int)\nNothing\n\n> second (One \"hello\" :: Can String Int)\nNothing\n\n> second (Eno 42 :: Can String Int)\nJust 42\n\n> second (Two \"hello\" 42)\nJust 42\n```\n","title":"second","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},null]},null]}},"sourceSpan":{"start":[276,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[276,41]}},{"children":[],"comments":"Grabs both an `a` and a `b` if they both exist, from the `Two` constructor.\n\n```purescript\n> both (Non :: Can String Int)\nNothing\n\n> both (One \"hello\" :: Can String Int)\nNothing\n\n> both (Eno 42 :: Can String Int)\nNothing\n\n> both (Two \"hello\" 42)\nJust (Tuple \"hello\" 42)\n```\n","title":"both","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]},null]},null]}},"sourceSpan":{"start":[294,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[294,49]}},{"children":[],"comments":"Checks if the constructor is `Non`.\n\n```purescript\n> isNone (Non :: Can String Int)\ntrue\n\n> isNone (One \"hello\" :: Can String Int)\nfalse\n\n> isNone (Eno 42 :: Can String Int)\nfalse\n\n> isNone (Two \"hello\" 42)\nfalse\n```\n","title":"isNone","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]},null]},null]}},"sourceSpan":{"start":[312,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[312,41]}},{"children":[],"comments":"Checks if the constructor is `One`.\n\n```purescript\n> isOne (Non :: Can String Int)\nfalse\n\n> isOne (One \"hello\" :: Can String Int)\ntrue\n\n> isOne (Eno 42 :: Can String Int)\nfalse\n\n> isOne (Two \"hello\" 42)\nfalse\n```\n","title":"isOne","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]},null]},null]}},"sourceSpan":{"start":[330,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[330,40]}},{"children":[],"comments":"Checks if the constructor is `Eno`.\n\n```purescript\n> isEno (Non :: Can String Int)\nfalse\n\n> isEno (One \"hello\" :: Can String Int)\nfalse\n\n> isEno (Eno 42 :: Can String Int)\ntrue\n\n> isEno (Two \"hello\" 42)\nfalse\n```\n","title":"isEno","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]},null]},null]}},"sourceSpan":{"start":[348,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[348,40]}},{"children":[],"comments":"Checks if the constructor is `Two`.\n\n```purescript\n> isTwo (Non :: Can String Int)\nfalse\n\n> isTwo (One \"hello\" :: Can String Int)\nfalse\n\n> isTwo (Eno 42 :: Can String Int)\nfalse\n\n> isTwo (Two \"hello\" 42)\ntrue\n```\n","title":"isTwo","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]},null]},null]}},"sourceSpan":{"start":[366,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[366,40]}},{"children":[],"comments":"Takes all `a` values from a `Foldable` `Can`. Note that values are extracted\nfrom both the `One` and `Two` constructors.\n\n```purescript\n> ones [Non :: Can String Int]\nNil\n\n> ones ([One \"hello\", One \"world\"] :: Array (Can String Int))\nCons \"hello\" (Cons \"world\" Nil)\n\n> ones ([Eno 42, Eno 13] :: Array (Can String Int))\nNil\n\n> ones ([Two \"hello\" 42, Two \"world\" 1] :: Array (Can String Int))\nCons \"hello\" (Cons \"world\" Nil)\n\n> ones [One \"hello\", Eno 42, Two \"world\" 13]\nCons \"hello\" (Cons \"world\" Nil)\n```\n","title":"ones","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["f",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Functor"],"Functor"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintData":null},{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Foldable"],"Foldable"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"List"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[388,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[388,71]}},{"children":[],"comments":"Takes all `b` values from a `Foldable` `Can`. Note that values are extracted\nfrom both the `Eno` and `Two` constructors.\n\n```purescript\n> enos [Non :: Can String Int]\nNil\n\n> enos ([One \"hello\", One \"world\"] :: Array (Can String Int))\nNil\n\n> enos ([Eno 42, Eno 13] :: Array (Can String Int))\nCons 42 (Cons 13 Nil)\n\n> enos ([Two \"hello\" 42, Two \"world\" 13] :: Array (Can String Int))\nCons 42 (Cons 13 Nil)\n\n> enos [One \"hello\", Eno 42, Two \"world\" 13]\nCons 42 (Cons 13 Nil)\n```\n","title":"enos","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["f",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Functor"],"Functor"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintData":null},{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Foldable"],"Foldable"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"List"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[410,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[410,71]}},{"children":[],"comments":"Takes all `a` and `b` values from a `Foldable` `Can`. Note that values are\nonly extracted from the `Two` constructor.\n\n```purescript\n> twos [Non :: Can String Int]\nNil\n\n> twos ([One \"hello\", One \"world\"] :: Array (Can String Int))\nNil\n\n> twos ([Eno \"hello\", Eno \"world\"] :: Array (Can String Int))\nNil\n\n> twos ([Two \"hello\" 42, Two \"world\" 1] :: Array (Can String Int))\nCons (Tuple \"hello\" 42) (Cons (Tuple \"world\" 1) Nil)\n```\n","title":"twos","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["f",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Functor"],"Functor"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintData":null},{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Foldable"],"Foldable"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"List"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[429,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[429,81]}},{"children":[],"comments":"Expand a `Can a b` to a `Maybe a` and a `Maybe b`. Note that the tuple\n`Tuple (Maybe a) (Maybe b)` is exactly equivalent with `Can a b`:\n\n```\n- Nothing, Nothing ~ Non\n- Just a , Nothing ~ One a\n- Nothing, Just b  ~ Eno b\n- Just a , Just b  ~ Two a b\n```\n","title":"curry","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[441,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[441,77]}},{"children":[],"comments":"Contract a `Maybe a` and a `Maybe b` to a `Can a b`. Note that `Can a b`\nis exactly equivalent with `Tuple (Maybe a) (Maybe b)`:\n\n```\nNon     ~ Nothing, Nothing\nOne a   ~ Just a , Nothing\nEno b   ~ Nothing, Just b\nTwo a b ~ Just a , Just b\n```\n","title":"uncurry","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[457,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[457,79]}},{"children":[],"comments":"Grab all `a` and `b` values from a `Foldable` `Can a b` and combine them\neach into an `Alternative` `f` tuple.\n\n```purescript\n> partition [Non, One \"hello\", Eno 42, Two \"world\" 1] :: Tuple (List String) (List Int)\nTuple (Cons \"hello\" (Cons \"world\" Nil)) (Cons 42 (Cons 1 Nil))\n```\n","title":"partition","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["t",{"annotation":[],"tag":"ForAll","contents":["f",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Foldable"],"Foldable"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"t"}],"constraintData":null},{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Control","Alternative"],"Alternative"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"t"},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]}]}]},null]},null]},null]},null]}},"sourceSpan":{"start":[471,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[476,23]}},{"children":[],"comments":"Maps `Can`s over a `Traversable` and partitions the values by their\nposition in the `Can`.\n\n```purescript\n> partitionMap (\\i -> if i < 3 then One i else Eno i) [1, 2, 3, 4, 5] :: Tuple (Array Int) (Array Int)\nTuple [1, 2] [3, 4, 5]\n```\n","title":"partitionMap","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["t",{"annotation":[],"tag":"ForAll","contents":["f",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Control","Alternative"],"Alternative"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintData":null},{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Traversable"],"Traversable"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"t"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"t"},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]}]}]}]}]},null]},null]},null]},null]},null]}},"sourceSpan":{"start":[493,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[499,23]}},{"children":[],"comments":"Distribute `Can` over a `Tuple`.\n\n```purescript\n> distribute (Non :: Can (Tuple String String) Int)\nTuple Non Non\n\n> distribute (One (Tuple \"hello\" \"world\") :: Can (Tuple String String) Int)\nTuple (One \"hello\") (One \"world\")\n\n> distribute (Eno 42 :: Can (Tuple String String) Int)\nTuple (Eno 42) (Eno 42)\n\n> distribute (Two (Tuple \"hello\" \"world\") 42 :: Can (Tuple String String) Int)\nTuple (Two \"hello\" 42) (Two \"world\" 42)\n```\n","title":"distribute","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]}]},null]},null]},null]}},"sourceSpan":{"start":[524,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[524,75]}},{"children":[],"comments":"Codistribute `Either` over a `Can`.\n\n```purescript\n> codistribute (Left Non :: Either (Can String Int) (Can Boolean Int))\nNon\n\n> codistribute (Left (One \"hello\") :: Either (Can String Int) (Can Boolean Int))\nOne (Left \"hello\")\n\n> codistribute (Left (Eno 42) :: Either (Can String Int) (Can Boolean Int))\nEno 42\n\n> codistribute (Left (Two \"hello\" 42) :: Either (Can String Int) (Can Boolean Int))\nTwo (Left \"hello\") 42\n\n> codistribute (Right Non :: Either (Can String Int) (Can Boolean Int))\nNon\n\n> codistribute (Right (One true) :: Either (Can String Int) (Can Boolean Int))\nOne (Right true)\n\n> codistribute (Right (Eno 42) :: Either (Can String Int) (Can Boolean Int))\nEno 42\n\n> codistribute (Right (Two true 42) :: Either (Can String Int) (Can Boolean Int))\nTwo (Right true) 42\n```\n","title":"codistribute","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Either"],"Either"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Either"],"Either"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]},null]},null]},null]}},"sourceSpan":{"start":[558,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[558,79]}},{"children":[],"comments":"Reassociates a `Can` from left to right.\nNote that `Eno c` and `Two Non c` both collapse to `Eno (Eno c)`, so\nit is NOT the case that `reassocLR <<< reassocRL = identity`.\n","title":"reassocLR","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]}]},null]},null]},null]}},"sourceSpan":{"start":[567,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[567,62]}},{"children":[],"comments":"Reassociates a `Can` from right to left.\nNote that `Eno c` and `Two Non c` both collapse to `Eno (Eno c)`, so\nit is NOT the case that `reassocLR <<< reassocRL = identity`.\n","title":"reassocRL","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]},null]},null]},null]}},"sourceSpan":{"start":[583,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[583,62]}},{"children":[],"comments":"Swap the inputs for a `Can`.\n\n```purescript\n> swap (Non :: Can String Int)\nNon\n\n> swap (One \"hello\" :: Can String Int)\nEno \"hello\"\n\n> swap (Eno 42 :: Can String Int)\nOne 42\n\n> swap (Two \"hello\" 42)\nTwo 42 \"hello\"\n```\n","title":"swap","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},null]},null]}},"sourceSpan":{"start":[611,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Can.purs","end":[611,39]}}]},{"reExports":[],"name":"Data.Pointed.Convert","comments":"This module defines conversion functions between Can, Smash, and Wedge.\n\nThe examples assume that the pointed modules are imported qualified:\n\n```purescript\nimport Data.Pointed.Can as C\nimport Data.Pointed.Smash as S\nimport Data.Pointed.Wedge as W\n```\n","declarations":[{"children":[],"comments":"Convert from `Can` to `Wedge`.\n\n```purescript\n> canSmash (C.Non :: Can String Int)\nS.Non\n\n> canSmash (C.One \"hello\" :: Can String Int)\nS.Non\n\n> canSmash (C.Eno 42 :: Can String Int)\nS.Non\n\n> canSmash (C.Two \"hello\" 42 :: Can String Int)\nS.Two \"hello\" 42\n```\n","title":"canSmash","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},null]},null]}},"sourceSpan":{"start":[36,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Convert.purs","end":[36,45]}},{"children":[],"comments":"Convert from `Wedge` to `Can`.\n\n```purescript\n> smashCan (S.Non :: Smash String Int)\nC.Non\n\n> smashCan (S.Two \"hello\" 42 :: Smash String Int)\nC.Two \"hello\" 42\n```\n","title":"smashCan","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},null]},null]}},"sourceSpan":{"start":[48,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Convert.purs","end":[48,45]}},{"children":[],"comments":"Convert from `Can` to `Wedge`.\n\n```purescript\n> canWedge (C.Non :: Can String Int)\nW.Non\n\n> canWedge (C.One \"hello\" :: Can String Int)\nW.One \"hello\"\n\n> canWedge (C.Eno 42 :: Can String Int)\nW.Eno 42\n\n> canWedge (C.Two \"hello\" 42 :: Can String Int)\nW.Non\n```\n","title":"canWedge","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},null]},null]}},"sourceSpan":{"start":[66,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Convert.purs","end":[66,45]}},{"children":[],"comments":"Convert from `Wedge` to `Can`.\n\n```purescript\n> wedgeCan (W.Non :: Wedge String Int)\nC.Non\n\n> wedgeCan (W.One \"hello\" :: Wedge String Int)\nC.One \"hello\"\n\n> wedgeCan (W.Eno 42 :: Wedge String Int)\nC.Eno 42\n```\n","title":"wedgeCan","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},null]},null]}},"sourceSpan":{"start":[81,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Convert.purs","end":[81,45]}},{"children":[],"comments":"Convert from `Wedge` to `Smash`, given default values for `a` and `b`.\n\n```purescript\n> hulkSmash \"world\" 1 (W.Non :: Wedge String Int)\nS.Non\n\n> hulkSmash \"world\" 1 (W.One \"hello\" :: Wedge String Int)\nS.Two \"hello\" 1\n\n> hulkSmash \"world\" 1 (W.Eno 42 :: Wedge String Int)\nC.Eno \"world\" 42\n```\n","title":"hulkSmash","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}]}]},null]},null]}},"sourceSpan":{"start":[96,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Convert.purs","end":[96,58]}}]},{"reExports":[],"name":"Data.Pointed.Distributivity","comments":"This module defines distributivity laws between Can, Smash, and Wedge.\n\nThe examples assume that the pointed modules are imported qualified:\n\n```purescript\nimport Data.Pointed.Can as C\nimport Data.Pointed.Smash as S\nimport Data.Pointed.Wedge as W\n```\n","declarations":[{"children":[],"comments":"`smashWedge` returns `W.Non` in all cases except:\n\n- `S.Two (W.One a) c`, in which case it returns `W.One (S.Two a c)`\n- `S.Two (W.Eno b) c`, in which case it returns `W.Eno (S.Two b c)`\n","title":"smashWedge","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]}]},null]},null]},null]}},"sourceSpan":{"start":[26,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Distributivity.purs","end":[26,81]}},{"children":[],"comments":"`wedgeSmash` returns `S.Non` in all cases except:\n\n- `W.One (S.Two a c)`, in which case it returns `S.Two (W.One a) c`\n- `W.Eno (S.Two b c)`, in which case it returns `S.Two (W.Eno b) c`\n","title":"wedgeSmash","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]},null]},null]},null]}},"sourceSpan":{"start":[36,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Distributivity.purs","end":[36,81]}},{"children":[],"comments":"`smashCan` returns `C.Non` unless its input is `S.Two can c`, in which case,\ndepending on `can`:\n\n- `C.Non` goes to `C.Non`\n- `C.One a` goes to `C.One (S.Two a c)`\n- `C.Eno b` goes to `C.Eno (S.Two b c)`\n- `C.Two a b` goes to `C.Two (S.Two a c) (S.Two b c)`\n","title":"smashCan","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]}]},null]},null]},null]}},"sourceSpan":{"start":[49,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Distributivity.purs","end":[49,75]}},{"children":[],"comments":"`canSmash` returns `S.Non` except when:\n\n`C.One (S.Two a c)` goes to `S.Two (C.One a) c`\n`C.Eno (S.Two b c)` goes to `S.Two (C.Eno b) c`\n`C.Two (S.Two a c)` goes to `S.Two (C.Two a b) c`\n","title":"canSmash","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]},null]},null]},null]}},"sourceSpan":{"start":[59,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Distributivity.purs","end":[59,75]}}]},{"reExports":[],"name":"Data.Pointed.Smash","comments":"This module defines the `Smash` type, along with instances and functions that\nhelp use this type. Generally, `Smash` is used when the data is isomorphic\nto `Maybe (Tuple a b)`.\n","declarations":[{"children":[{"comments":null,"title":"Non","info":{"arguments":[],"declType":"dataConstructor"},"sourceSpan":null},{"comments":null,"title":"Two","info":{"arguments":[{"annotation":[],"tag":"TypeVar","contents":"a"},{"annotation":[],"tag":"TypeVar","contents":"b"}],"declType":"dataConstructor"},"sourceSpan":null},{"comments":null,"title":"eqSmash","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Eq"],"Eq"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null},{"constraintAnn":[],"constraintClass":[["Data","Eq"],"Eq"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"b"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Eq"],"Eq"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}},"sourceSpan":{"start":[27,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Smash.purs","end":[27,58]}},{"comments":null,"title":"ordSmash","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Ord"],"Ord"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null},{"constraintAnn":[],"constraintClass":[["Data","Ord"],"Ord"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"b"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Ord"],"Ord"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}},"sourceSpan":{"start":[28,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Smash.purs","end":[28,62]}},{"comments":null,"title":"genericSmash","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Generic","Rep"],"Generic"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeWildcard","contents":null}]}},"sourceSpan":{"start":[29,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Smash.purs","end":[29,54]}},{"comments":null,"title":"functorSmash","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Functor"],"Functor"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[30,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Smash.purs","end":[30,50]}},{"comments":null,"title":"semigroupSmash","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null},{"constraintAnn":[],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"b"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Semigroup"],"Semigroup"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}},"sourceSpan":{"start":[32,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Smash.purs","end":[36,54]}},{"comments":null,"title":"monoidSmash","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null},{"constraintAnn":[],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"b"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Monoid"],"Monoid"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}},"sourceSpan":{"start":[38,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Smash.purs","end":[39,15]}},{"comments":"```purescript\n> bimap show (_ + 10) (Non :: Smash Int Int)\nNon\n\n> bimap show (_ + 10) (Two 42 1 :: Smash Int Int)\nTwo \"42\" 11\n```\n","title":"bifunctorSmash","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Bifunctor"],"Bifunctor"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]}]}},"sourceSpan":{"start":[48,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Smash.purs","end":[51,31]}},{"comments":null,"title":"biapplySmash","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Biapply"],"Biapply"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]}]}},"sourceSpan":{"start":[53,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Smash.purs","end":[56,27]}},{"comments":null,"title":"biapplicativeSmash","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Biapplicative"],"Biapplicative"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]}]}},"sourceSpan":{"start":[58,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Smash.purs","end":[59,15]}},{"comments":null,"title":"bifoldableSmash","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Bifoldable"],"Bifoldable"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]}]}},"sourceSpan":{"start":[61,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Smash.purs","end":[67,39]}},{"comments":null,"title":"bitraversableSmash","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Bitraversable"],"Bitraversable"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]}]}},"sourceSpan":{"start":[69,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Smash.purs","end":[74,33]}},{"comments":null,"title":"applySmash","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Apply"],"Apply"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[76,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Smash.purs","end":[79,30]}},{"comments":null,"title":"applicativeSmash","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Monoid"],"Monoid"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Applicative"],"Applicative"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[81,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Smash.purs","end":[82,20]}},{"comments":null,"title":"bindSmash","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Monoid"],"Monoid"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Bind"],"Bind"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[84,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Smash.purs","end":[89,35]}},{"comments":null,"title":"monadSmash","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Monoid"],"Monoid"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Monad"],"Monad"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[91,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Smash.purs","end":[91,51]}},{"comments":null,"title":"foldableSmash","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Foldable"],"Foldable"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[93,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Smash.purs","end":[97,31]}},{"comments":null,"title":"traversableSmash","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Traversable"],"Traversable"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[99,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Smash.purs","end":[101,29]}}],"comments":"`Smash` `a` `b` can hold either no values or an `a` and a `b`.  The type is\nisomorphic with `Maybe (Tuple a b)`.\n","title":"Smash","info":{"declType":"data","dataDeclType":"data","typeArguments":[["a",null],["b",null]]},"sourceSpan":{"start":[23,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Smash.purs","end":[25,12]}},{"children":[],"comments":"Constructs a `Smash` given an isomorphic representation. Note that this is\nthe precise inverse of `toMaybe`.\n\n```purescript\n> fromMaybe Nothing :: Smash String Int\nNon\n\n> fromMaybe (Just (Tuple \"hello\" 42)) :: Smash String Int\nTwo \"hello\" 42\n```\n","title":"fromMaybe","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},null]},null]}},"sourceSpan":{"start":[113,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Smash.purs","end":[113,56]}},{"children":[],"comments":"Destructs a `Smash` from an isomorphic representation. Note that this is\nthe precise inverse of `fromMaybe`.\n\n```purescript\n> toMaybe Non :: Smash String Int\nNothing\n\n> toMaybe (Two \"hello\" 42 :: Smash String Int)\nJust (Tuple \"hello\" 42)\n```\n","title":"toMaybe","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]},null]},null]}},"sourceSpan":{"start":[126,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Smash.purs","end":[126,54]}},{"children":[],"comments":"`Smash` catamorphism (fold). Takes an input for each possible constructor and\ntranslates it to `c`.\n\nFor example, we can go from some `s :: Smash a b` to a\n`Maybe (Tuple a b)` using:\n\n```purescript\n> smash Nothing (\\a b -> Just (Tuple a b)) (Non :: Smash String Int)\nNothing\n\n> smash Nothing (\\a b -> Just (Tuple a b)) (Two \"hello\" 43 :: Smash String Int)\nJust (Tuple \"hello\" 42)\n```\n","title":"smash","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"c"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[142,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Smash.purs","end":[142,60]}},{"children":[],"comments":"Grabs an `a` if it exists, otherwise returns nothing.\n\n```purescript\n> first (Non :: Smash String Int)\nNothing\n\n> first (Two \"hello\" 42 :: Smash String Int)\nJust \"hello\"\n```\n","title":"first","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},null]},null]}},"sourceSpan":{"start":[156,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Smash.purs","end":[156,42]}},{"children":[],"comments":"Grabs a `b` if it exists, otherwise returns nothing.\n\n```purescript\n> second (Non :: Smash String Int)\nNothing\n\n> second (Two \"hello\" 42 :: Smash String Int)\nJust 42\n```\n","title":"second","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},null]},null]}},"sourceSpan":{"start":[168,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Smash.purs","end":[168,43]}},{"children":[],"comments":"Grabs an `a` and a `b` if they exist, otherwise returns nothing.\n\n```purescript\n> second (Non :: Smash String Int)\nNothing\n\n> second (Two \"hello\" 42 :: Smash String Int)\nJust (Tuple \"hello\" 42)\n```\n","title":"both","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]},null]},null]}},"sourceSpan":{"start":[180,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Smash.purs","end":[180,51]}},{"children":[],"comments":"Checks if the constructor is `Non`.\n\n```purescript\n> isNone (Non :: Smash String Int)\ntrue\n\n> isNone (Two \"hello\" 42 :: Smash String Int)\nfalse\n```\n","title":"isNone","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]},null]},null]}},"sourceSpan":{"start":[192,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Smash.purs","end":[192,43]}},{"children":[],"comments":"Checks if the constructor is `Two`.\n\n```purescript\n> isNone (Non :: Smash String Int)\nfalse\n\n> isNone (Two \"hello\" 42 :: Smash String Int)\ntrue\n```\n","title":"isTwo","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]},null]},null]}},"sourceSpan":{"start":[204,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Smash.purs","end":[204,42]}},{"children":[],"comments":"Takes all `a` and `b` values from a `Foldable` `Smash`.\n\n```purescript\n> twos [Non :: Smash String Int]\nNil\n\n> twos ([Two \"hello\" 42, Non, Two \"world\" 1] :: Array (Smash String Int))\nCons (Tuple \"hello\" 42) (Cons (Tuple \"world\" 1) Nil)\n```\n","title":"twos","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["f",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Functor"],"Functor"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintData":null},{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Foldable"],"Foldable"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"List"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[216,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Smash.purs","end":[216,83]}},{"children":[],"comments":"Expand a `Smash a b` to a `Maybe a` and a `Maybe b`. Note that the tuple\n`Tuple (Maybe a) (Maybe b)` has more information that we can store in a\n`Smash a b`.\n\n```\nNothing, Nothing ~ Non\nJust a , Nothing ~ Non\nNothing, Just b  ~ Non\nJust a , Just b  ~ Two a b\n```\n","title":"curry","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[229,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Smash.purs","end":[229,79]}},{"children":[],"comments":"Contract a `Smash a b` to a `Maybe a` and a `Maybe b`. Note that the tuple\n`Tuple (Maybe a) (Maybe b)` has more information that we can store in a\n`Smash a b`.\n\n```\nNon     ~ Nothing, Nothing\nTwo a b ~ Just a , Just b\n```\n","title":"uncurry","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[242,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Smash.purs","end":[242,81]}},{"children":[],"comments":"Grab all `a` and `b` values from a `Foldable` `Smash a b` and combine them\neach into an `Alternative` `f` tuple.\n\n```purescript\n> partition [Non, Two \"hello\" 42, Two \"world\" 1] :: Tuple (List String) (List Int)\nTuple (Cons \"hello\" (Cons \"world\" Nil)) (Cons 42 (Cons 1 Nil))\n```\n","title":"partition","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["t",{"annotation":[],"tag":"ForAll","contents":["f",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Foldable"],"Foldable"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"t"}],"constraintData":null},{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Control","Alternative"],"Alternative"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"t"},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]}]}]},null]},null]},null]},null]}},"sourceSpan":{"start":[254,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Smash.purs","end":[259,23]}},{"children":[],"comments":"Maps `Smash`es over a `Traversable` and partitions the values by their\nposition in the `Smash`.\n\n```purescript\n> partitionMap (\\i -> if i < 3 then Non else Two i (i*10)) [1, 2, 3, 4, 5] :: Tuple (Array Int) (Array Int)\nTuple [3, 4, 5] [30, 40, 50]\n```\n","title":"partitionMap","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["t",{"annotation":[],"tag":"ForAll","contents":["f",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Control","Alternative"],"Alternative"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintData":null},{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Traversable"],"Traversable"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"t"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"t"},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]}]}]}]}]},null]},null]},null]},null]},null]}},"sourceSpan":{"start":[274,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Smash.purs","end":[280,23]}},{"children":[],"comments":"Distribute `Smash` over a `Tuple`.\n\n```purescript\n> distribute (Non :: Smash (Tuple String String) Int)\nTuple Non Non\n\n> distribute (Two (Tuple \"hello\" \"world\") 42 :: Smash (Tuple String String) Int)\nTuple (Two \"hello\" 42) (Two \"world\" 42)\n```\n","title":"distribute","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]}]},null]},null]},null]}},"sourceSpan":{"start":[297,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Smash.purs","end":[297,81]}},{"children":[],"comments":"Distribute a `Tuple` over `Smash`.\n\n```purescript\n> redistribute (Tuple Non Non :: Tuple (Smash String Int) (Smash String Int))\nNon\n\n> redistribute Tuple (Two \"hello\" 42) (Two \"world\" 42)\nTwo (Tuple \"hello\" \"world\") 42\n```\n","title":"redistribute","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]},null]},null]},null]}},"sourceSpan":{"start":[312,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Smash.purs","end":[312,83]}},{"children":[],"comments":"Reassociates a `Smash` from left to right.\nNote that `Non` and `Two Non c` both collapse to `Non`, so\nit is NOT the case that `reassocLR <<< reassocRL = identity`.\n","title":"reassocLR","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]}]},null]},null]},null]}},"sourceSpan":{"start":[320,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Smash.purs","end":[320,70]}},{"children":[],"comments":"Reassociates a `Smash` from right to left.\nNote that `Non` and `Two Non c` both collapse to `Non`, so\nit is NOT the case that `reassocLR <<< reassocRL = identity`.\n","title":"reassocRL","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]},null]},null]},null]}},"sourceSpan":{"start":[328,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Smash.purs","end":[328,70]}},{"children":[],"comments":"Swap the inputs for a `Smash`.\n\n```purescript\n> swap (Non :: Smash String Int)\nNon\n\n> swap (Two \"hello\" 42)\nTwo 42 \"hello\"\n```\n","title":"swap","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},null]},null]}},"sourceSpan":{"start":[342,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Smash.purs","end":[342,43]}}]},{"reExports":[],"name":"Data.Pointed.Wedge","comments":"This module defines the `Wedge` type, along with instances and functions that\nhelp use this type. Generally, `Wedge` is used when the data is more vague\nthan simply using `Either a b`, i.e. when either or both `a` and `b` might\nbe missing.\n","declarations":[{"children":[{"comments":null,"title":"Non","info":{"arguments":[],"declType":"dataConstructor"},"sourceSpan":null},{"comments":null,"title":"One","info":{"arguments":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"declType":"dataConstructor"},"sourceSpan":null},{"comments":null,"title":"Eno","info":{"arguments":[{"annotation":[],"tag":"TypeVar","contents":"b"}],"declType":"dataConstructor"},"sourceSpan":null},{"comments":null,"title":"eqWedge","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Eq"],"Eq"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null},{"constraintAnn":[],"constraintClass":[["Data","Eq"],"Eq"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"b"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Eq"],"Eq"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}},"sourceSpan":{"start":[29,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Wedge.purs","end":[29,58]}},{"comments":null,"title":"ordWedge","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Ord"],"Ord"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null},{"constraintAnn":[],"constraintClass":[["Data","Ord"],"Ord"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"b"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Ord"],"Ord"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}},"sourceSpan":{"start":[30,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Wedge.purs","end":[30,62]}},{"comments":null,"title":"genericWedge","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Generic","Rep"],"Generic"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeWildcard","contents":null}]}},"sourceSpan":{"start":[31,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Wedge.purs","end":[31,54]}},{"comments":null,"title":"functorWedge","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Functor"],"Functor"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[32,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Wedge.purs","end":[32,50]}},{"comments":"The `Semigroup` instance may lose information (biased towards `Eno`):\n\n```purescript\n> (One \"hello\" :: Wedge String Int) <> (Eno 42 :: Wedge String Int)\nEno 42\n```\n","title":"semigroupWedge","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null},{"constraintAnn":[],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"b"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Semigroup"],"Semigroup"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}},"sourceSpan":{"start":[40,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Wedge.purs","end":[47,37]}},{"comments":null,"title":"monoidWedge","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null},{"constraintAnn":[],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"b"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Monoid"],"Monoid"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}},"sourceSpan":{"start":[50,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Wedge.purs","end":[51,15]}},{"comments":"```purescript\n> bimap show (_ + 10) (Non :: Wedge Int Int)\nNon\n\n> bimap show (_ + 10) (One 42 :: Wedge Int Int)\nOne \"42\"\n\n> bimap show (_ + 10) (Eno 1 :: Wedge Int Int)\nOne 11\n```\n","title":"bifunctorWedge","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Bifunctor"],"Bifunctor"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]}]}},"sourceSpan":{"start":[63,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Wedge.purs","end":[67,23]}},{"comments":null,"title":"biapplyWedge","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Biapply"],"Biapply"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]}]}},"sourceSpan":{"start":[69,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Wedge.purs","end":[73,23]}},{"comments":null,"title":"bifoldableWedge","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Bifoldable"],"Bifoldable"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]}]}},"sourceSpan":{"start":[75,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Wedge.purs","end":[82,39]}},{"comments":null,"title":"bitraversableWedge","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Bitraversable"],"Bitraversable"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]}]}},"sourceSpan":{"start":[84,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Wedge.purs","end":[90,33]}},{"comments":null,"title":"applyWedge","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Apply"],"Apply"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[92,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Wedge.purs","end":[98,30]}},{"comments":null,"title":"applicativeWedge","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Monoid"],"Monoid"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Applicative"],"Applicative"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[100,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Wedge.purs","end":[101,13]}},{"comments":null,"title":"bindWedge","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Monoid"],"Monoid"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Bind"],"Bind"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[103,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Wedge.purs","end":[107,17]}},{"comments":null,"title":"monadWedge","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Monoid"],"Monoid"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Monad"],"Monad"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[109,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Wedge.purs","end":[109,51]}},{"comments":null,"title":"foldableWedge","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Foldable"],"Foldable"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[111,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Wedge.purs","end":[115,31]}},{"comments":null,"title":"traversableWedge","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Traversable"],"Traversable"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[117,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Wedge.purs","end":[119,29]}}],"comments":"`Wedge` `a` `b` can hold either no values, an `a`, or a `b`.  The type is\nisomorphic with `Maybe (Either a b)`.\n","title":"Wedge","info":{"declType":"data","dataDeclType":"data","typeArguments":[["a",null],["b",null]]},"sourceSpan":{"start":[24,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Wedge.purs","end":[27,10]}},{"children":[],"comments":"Constructs a `Wedge` given an isomorphic representation. Note that this is\nthe precise inverse of `toMaybeEither`.\n\n```purescript\n> fromMaybeEither Nothing :: Wedge String Int\nNon\n\n> fromMaybeEither (Just (Left \"hello\")) :: Wedge String Int\nOne \"hello\"\n\n> fromMaybeEither (Just (Right 42)) :: Wedge String Int\nEno 42\n```\n","title":"fromMaybeEither","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Either"],"Either"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},null]},null]}},"sourceSpan":{"start":[134,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Wedge.purs","end":[134,63]}},{"children":[],"comments":"Destructs a `Wedge` from an isomorphic representation. Note that this is\nthe precise inverse of `fromMaybeEither`.\n\n```purescript\n> toMaybeEither (Non :: Wedge String Int)\nNothing\n\n> toMaybeEither (One \"hello\" :: Wedge String Int)\nJust (Left \"hello\")\n\n> toMaybeEither (Eno 42 :: Wedge String Int)\nJust (Right 42)\n```\n","title":"toMaybeEither","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Either"],"Either"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]},null]},null]}},"sourceSpan":{"start":[150,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Wedge.purs","end":[150,61]}},{"children":[],"comments":"Constructs a `Wedge` given an either of maybes. Note that this is\nthe precise inverse of `toMaybeEither`.\n\n```purescript\n> fromEitherMaybe (Left Nothing) :: Wedge String Int\nNon\n\n> fromEitherMaybe (Left (Just \"hello\")) :: Wedge String Int\nOne \"hello\"\n\n> fromEitherMaybe (Right Nothing) :: Wedge String Int\nNon\n\n> fromEitherMaybe (Right (Just 42)) :: Wedge String Int\nEno 42\n```\n","title":"fromEitherMaybe","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Either"],"Either"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},null]},null]}},"sourceSpan":{"start":[169,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Wedge.purs","end":[169,71]}},{"children":[],"comments":"Constructs a left-biased `Wedge`.\n\n```purescript\n> fromMaybeOne Nothing :: Wedge String Int\nNon\n\n> fromMaybeOne (Just \"hello\") :: Wedge String Int\nOne \"hello\"\n```\n","title":"fromMaybeOne","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},null]},null]}},"sourceSpan":{"start":[181,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Wedge.purs","end":[181,49]}},{"children":[],"comments":"Constructs a right-biased `Wedge`.\n\n```purescript\n> fromMaybeTwo Nothing :: Wedge String Int\nNon\n\n> fromMaybeTwo (Just 42) :: Wedge String Int\nEno 42\n```\n","title":"fromMaybeEno","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},null]},null]}},"sourceSpan":{"start":[193,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Wedge.purs","end":[193,49]}},{"children":[],"comments":"`Wedge` catamorphism (fold). Takes an input for each possible constructor and\ntranslates it to `c`.\n\nFor example, we can go from some `w :: Wedge a b` to a\n`Maybe (Either a b)` using:\n\n```purescript\n> wedge Nothing Left Right (Non :: Wedge String Int)\nNon\n\n> wedge Nothing Left Right (One \"hello\" :: Wedge String Int)\nJust (Left \"hello\")\n\n> wedge Nothing Left Right (Eno 42 :: Wedge String Int)\nJust (Right 42)\n```\n","title":"wedge","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"c"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[212,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Wedge.purs","end":[212,67]}},{"children":[],"comments":"Grabs an `a` if it exists, otherwise returns nothing.\n\n```purescript\n> first (Non :: Wedge String Int)\nNothing\n\n> first (One \"hello\" :: Wedge String Int)\nJust \"hello\"\n\n> first (Eno 42 :: Wedge String Int)\nNothing\n```\n","title":"first","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},null]},null]}},"sourceSpan":{"start":[230,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Wedge.purs","end":[230,42]}},{"children":[],"comments":"Grabs a `b` if it exists, otherwise returns nothing.\n\n```purescript\n> second (Non :: Wedge String Int)\nNothing\n\n> second (One \"hello\" :: Wedge String Int)\nNothing\n\n> second (Eno 42 :: Wedge String Int)\nJust 42\n```\n","title":"second","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},null]},null]}},"sourceSpan":{"start":[245,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Wedge.purs","end":[245,43]}},{"children":[],"comments":"Checks if the constructor is `Non`.\n\n```purescript\n> isNone (Non :: Wedge String Int)\ntrue\n\n> isNone (One \"hello\" :: Wedge String Int)\nfalse\n\n> isNone (Eno 42 :: Wedge String Int)\nfalse\n```\n","title":"isNone","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]},null]},null]}},"sourceSpan":{"start":[260,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Wedge.purs","end":[260,43]}},{"children":[],"comments":"Checks if the constructor is `One`.\n\n```purescript\n> isOne (Non :: Wedge String Int)\nfalse\n\n> isOne (One \"hello\" :: Wedge String Int)\ntrue\n\n> isOne (Eno 42 :: Wedge String Int)\nfalse\n```\n","title":"isOne","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]},null]},null]}},"sourceSpan":{"start":[275,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Wedge.purs","end":[275,42]}},{"children":[],"comments":"Checks if the constructor is `Eno`.\n\n```purescript\n> isEno (Non :: Wedge String Int)\nfalse\n\n> isEno (One \"hello\" :: Wedge String Int)\nfalse\n\n> isEno (Eno 42 :: Wedge String Int)\ntrue\n```\n","title":"isEno","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]},null]},null]}},"sourceSpan":{"start":[290,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Wedge.purs","end":[290,42]}},{"children":[],"comments":"Takes all `a` values from a `Foldable` `Wedge`.\n\n```purescript\n> ones [Non :: Wedge String Int]\nNil\n\n> ones ([One \"hello\", One \"world\"] :: Array (Wedge String Int))\nCons \"hello\" (Cons \"world\" Nil)\n\n> ones ([Eno 42, Eno 13] :: Array (Wedge String Int))\nNil\n\n> ones ([One \"hello\", Eno 42] :: Array (Wedge String Int))\nCons \"hello\" Nil\n```\n","title":"ones","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["f",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Functor"],"Functor"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintData":null},{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Foldable"],"Foldable"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"List"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[308,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Wedge.purs","end":[308,73]}},{"children":[],"comments":"Takes all `b` values from a `Foldable` `Wedge`.\n\n```purescript\n> enos [Non :: Wedge String Int]\nNil\n\n> enos ([One \"hello\", One \"world\"] :: Array (Wedge String Int))\nNil\n\n> enos ([Eno 42, Eno 13] :: Array (Wedge String Int))\nCons 42 (Cons 13 Nil)\n\n> enos ([One \"hello\", Eno 42] :: Wedge String Int)\nCons 42 Nil\n```\n","title":"enos","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["f",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Functor"],"Functor"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintData":null},{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Foldable"],"Foldable"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"List"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[326,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Wedge.purs","end":[326,73]}},{"children":[],"comments":"Grab all `a` and `b` values from a `Foldable` `Wedge a b` and combine them\neach into an `Alternative` `f` tuple.\n\n```purescript\n> partition [Non, One \"hello\", Eno 42] :: Tuple (List String) (List Int)\nTuple (Cons \"hello\" Nil) (Cons 42)\n```\n","title":"partition","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["t",{"annotation":[],"tag":"ForAll","contents":["f",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Foldable"],"Foldable"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"t"}],"constraintData":null},{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Control","Alternative"],"Alternative"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"t"},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]}]}]},null]},null]},null]},null]}},"sourceSpan":{"start":[336,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Wedge.purs","end":[341,23]}},{"children":[],"comments":"Maps `Wedge`s over a `Traversable` and partitions the values by their\nposition in the `Wedge`.\n\n```purescript\n> partitionMap (\\i -> if i < 3 then One i else Eno i) [1, 2, 3, 4, 5] :: Tuple (Array Int) (Array Int)\nTuple [1, 2] [3, 4, 5]\n```\n","title":"partitionMap","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["t",{"annotation":[],"tag":"ForAll","contents":["f",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Control","Alternative"],"Alternative"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintData":null},{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Traversable"],"Traversable"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"t"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"t"},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]}]}]}]}]},null]},null]},null]},null]},null]}},"sourceSpan":{"start":[357,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Wedge.purs","end":[363,23]}},{"children":[],"comments":"Distribute `Wedge` over a `Tuple`.\n\n```purescript\n> distribute (Non :: Wedge (Tuple String String) Int)\nTuple Non Non\n\n> distribute (One (Tuple \"hello\" \"world\") :: Wedge (Tuple String String) Int)\nTuple (One \"hello\") (One \"world\")\n\n> distribute (Eno 42 :: Wedge (Tuple String String) Int)\nTuple (Eno 42) (Eno 42)\n```\n","title":"distribute","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]}]},null]},null]},null]}},"sourceSpan":{"start":[384,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Wedge.purs","end":[384,81]}},{"children":[],"comments":"Codistribute `Either` over a `Wedge`.\n\n```purescript\n> codistribute (Left Non :: Either (Wedge String Int) (Wedge Boolean Int))\nNon\n\n> codistribute (Left (One \"hello\") :: Either (Wedge String Int) (Wedge Boolean Int))\nOne (Left \"hello\")\n\n> codistribute (Left (Eno 42) :: Either (Wedge String Int) (Wedge Boolean Int))\nEno 42\n\n> codistribute (Right Non :: Either (Wedge String Int) (Wedge Boolean Int))\nNon\n\n> codistribute (Right (One true) :: Either (Wedge String Int) (Wedge Boolean Int))\nOne (Right true)\n\n> codistribute (Right (Eno 42) :: Either (Wedge String Int) (Wedge Boolean Int))\nEno 42\n```\n","title":"codistribute","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Either"],"Either"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Either"],"Either"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]},null]},null]},null]}},"sourceSpan":{"start":[411,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Wedge.purs","end":[411,85]}},{"children":[],"comments":"Reassociates a `Wedge` from left to right.\nNote that this is the inverse of `reassocRL`, i.e.:\n`reassocRL <<< reassocLR = identity`.\n","title":"reassocLR","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]}]},null]},null]},null]}},"sourceSpan":{"start":[420,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Wedge.purs","end":[420,70]}},{"children":[],"comments":"Reassociates a `Wedge` from right to left.\nNote that this is the inverse of `reassocLR`, i.e.:\n`reassocRL <<< reassocLR = identity`.\n","title":"reassocRL","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]},null]},null]},null]}},"sourceSpan":{"start":[431,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Wedge.purs","end":[431,70]}},{"children":[],"comments":"Swap the inputs for a `Wedge`.\n\n```purescript\n> swap (Non :: Wedge String Int)\nNon\n\n> swap (One \"hello\" :: Wedge String Int)\nEno \"hello\"\n\n> swap (Eno 42 :: Wedge String Int)\nOne 42\n```\n","title":"swap","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},null]},null]}},"sourceSpan":{"start":[451,1],"name":"/home/vlad/code/pointed/src/Data/Pointed/Wedge.purs","end":[451,43]}}]}],"resolvedDependencies":{"purescript-newtype":"3.0.0","purescript-effect":"2.0.1","purescript-control":"4.2.0","purescript-either":"4.1.1","purescript-maybe":"4.0.1","purescript-type-equality":"3.0.0","purescript-distributive":"4.0.0","purescript-unfoldable":"4.1.0","purescript-invariant":"4.1.0","purescript-lazy":"4.0.0","purescript-foldable-traversable":"4.1.1","purescript-tailrec":"4.1.1","purescript-gen":"2.1.1","purescript-prelude":"4.1.1","purescript-bifunctors":"4.0.0","purescript-nonempty":"5.0.0","purescript-refs":"4.1.0","purescript-orders":"4.0.0","purescript-generics-rep":"6.1.1","purescript-enums":"4.0.1","purescript-tuples":"5.1.0","purescript-partial":"2.0.1","purescript-identity":"4.1.0","purescript-lists":"5.4.1"},"version":"0.1.1","github":["vladciobanu","purescript-pointed"],"versionTag":"v0.1.1","moduleMap":{"Data.BooleanAlgebra":"purescript-prelude","Data.Ring":"purescript-prelude","Data.NonEmpty":"purescript-nonempty","Effect.Uncurried":"purescript-effect","Effect":"purescript-effect","Data.Traversable.Accum.Internal":"purescript-foldable-traversable","Data.Enum.Gen":"purescript-enums","Data.Bifunctor.Flip":"purescript-bifunctors","Data.Ord":"purescript-prelude","Control.Monad.Gen":"purescript-gen","Type.Data.Row":"purescript-prelude","Data.Monoid.Dual":"purescript-prelude","Data.Generic.Rep.Ring":"purescript-generics-rep","Control.Monad.Rec.Class":"purescript-tailrec","Data.Bitraversable":"purescript-foldable-traversable","Data.Boolean":"purescript-prelude","Control.Biapplicative":"purescript-bifunctors","Data.Bounded":"purescript-prelude","Data.TraversableWithIndex":"purescript-foldable-traversable","Data.Show":"purescript-prelude","Data.Bifunctor.Clown":"purescript-bifunctors","Data.Foldable":"purescript-foldable-traversable","Data.Enum":"purescript-enums","Control.Apply":"purescript-prelude","Data.Tuple.Nested":"purescript-tuples","Data.Generic.Rep.Semigroup":"purescript-generics-rep","Control.Monad":"purescript-prelude","Data.Lazy":"purescript-lazy","Data.Monoid":"purescript-prelude","Data.Maybe.First":"purescript-maybe","Control.Bind":"purescript-prelude","Data.Monoid.Additive":"purescript-prelude","Data.Symbol":"purescript-prelude","Data.HeytingAlgebra":"purescript-prelude","Control.Alt":"purescript-control","Type.Data.RowList":"purescript-prelude","Effect.Ref":"purescript-refs","Data.Either.Inject":"purescript-either","Data.List.ZipList":"purescript-lists","Data.Ord.Min":"purescript-orders","Data.Ord.Unsafe":"purescript-prelude","Data.Semigroup":"purescript-prelude","Data.Generic.Rep.Enum":"purescript-generics-rep","Data.Generic.Rep.Bounded":"purescript-generics-rep","Data.Ord.Down":"purescript-orders","Data.Generic.Rep.Show":"purescript-generics-rep","Effect.Unsafe":"purescript-effect","Data.Tuple":"purescript-tuples","Data.Semigroup.Foldable":"purescript-foldable-traversable","Control.Biapply":"purescript-bifunctors","Data.Distributive":"purescript-distributive","Type.Equality":"purescript-type-equality","Control.Alternative":"purescript-control","Data.Semiring":"purescript-prelude","Data.Traversable.Accum":"purescript-foldable-traversable","Data.CommutativeRing":"purescript-prelude","Data.NaturalTransformation":"purescript-prelude","Data.Monoid.Conj":"purescript-prelude","Data.Unfoldable":"purescript-unfoldable","Data.List.Types":"purescript-lists","Data.Functor":"purescript-prelude","Data.Generic.Rep.Ord":"purescript-generics-rep","Data.List.Lazy.Types":"purescript-lists","Control.Category":"purescript-prelude","Control.Monad.Gen.Common":"purescript-gen","Data.Maybe":"purescript-maybe","Control.Comonad":"purescript-control","Data.Function":"purescript-prelude","Data.List":"purescript-lists","Data.Field":"purescript-prelude","Data.List.Lazy":"purescript-lists","Data.Generic.Rep.Eq":"purescript-generics-rep","Data.EuclideanRing":"purescript-prelude","Data.Semigroup.Last":"purescript-prelude","Data.Semigroup.First":"purescript-prelude","Data.Functor.Invariant":"purescript-invariant","Prelude":"purescript-prelude","Effect.Class":"purescript-effect","Partial.Unsafe":"purescript-partial","Data.Bifunctor.Product":"purescript-bifunctors","Control.Extend":"purescript-control","Data.Unfoldable1":"purescript-unfoldable","Control.Lazy":"purescript-control","Data.Eq":"purescript-prelude","Data.Either.Nested":"purescript-either","Data.Newtype":"purescript-newtype","Data.Semigroup.Traversable":"purescript-foldable-traversable","Data.Bifunctor":"purescript-bifunctors","Data.Monoid.Disj":"purescript-prelude","Control.Monad.Gen.Class":"purescript-gen","Control.MonadPlus":"purescript-control","Data.Void":"purescript-prelude","Control.MonadZero":"purescript-control","Data.Ord.Max":"purescript-orders","Data.Bifunctor.Joker":"purescript-bifunctors","Data.FunctorWithIndex":"purescript-foldable-traversable","Data.DivisionRing":"purescript-prelude","Data.Bifunctor.Wrap":"purescript-bifunctors","Data.Maybe.Last":"purescript-maybe","Data.Unit":"purescript-prelude","Data.List.NonEmpty":"purescript-lists","Data.Generic.Rep.Semiring":"purescript-generics-rep","Data.List.Lazy.NonEmpty":"purescript-lists","Data.Ordering":"purescript-prelude","Data.Identity":"purescript-identity","Control.Plus":"purescript-control","Partial":"purescript-partial","Data.Monoid.Multiplicative":"purescript-prelude","Data.Generic.Rep.HeytingAlgebra":"purescript-generics-rep","Data.Generic.Rep.Monoid":"purescript-generics-rep","Control.Semigroupoid":"purescript-prelude","Data.Monoid.Alternate":"purescript-control","Data.Generic.Rep":"purescript-generics-rep","Data.Bifunctor.Join":"purescript-bifunctors","Data.Bifoldable":"purescript-foldable-traversable","Data.Monoid.Endo":"purescript-prelude","Data.List.Partial":"purescript-lists","Data.Either":"purescript-either","Control.Applicative":"purescript-prelude","Data.FoldableWithIndex":"purescript-foldable-traversable","Record.Unsafe":"purescript-prelude","Data.Traversable":"purescript-foldable-traversable"},"compilerVersion":"0.13.3"}