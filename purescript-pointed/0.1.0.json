{"uploader":"vladciobanu","packageMeta":{"repository":{"url":"https://github.com/vladciobanu/purescript-pointed","type":"git"},"ignore":["**/.*","node_modules","bower_components","output"],"dependencies":{"purescript-maybe":"^v4.0.1","purescript-foldable-traversable":"^v4.1.1","purescript-bifunctors":"^v4.0.0","purescript-generics-rep":"^v6.1.1","purescript-lists":"^v5.4.1"},"name":"purescript-pointed","license":["MIT"]},"tagTime":"2020-10-09T08:31:41+0000","modules":[{"reExports":[],"name":"Data.Pointed.Can","comments":"This module defines the type `Can`, along with instances and functions that\nhelp use this type. Generally, 'Can' is used when the data is more vague\nthan simply using 'Either a b' or 'Tuple a b', i.e. when either 'a' or 'b'\nmight be missing or be present independently.\n\n'Can' values can be compared. Note that they are only equal if they are\nprecisely equal.\n\n> (One \"hello\" :: Can String Int) == (Two \"hello\" 42 :: Can String Int)\nfalse\n\nThe `Semigroup` instance will never lose information and requires both\n'a' and 'b' to have 'Semigroup' instances:\n\n> (One \"hello\" :: Can String String) <> Two \"world\" \"42\"\nTwo \"helloworld\" \"42\"\n\nWe can map over both arguments using `bimap`:\n> bimap show (_ + 10) (Two 42 32)\nTwo \"42\" 42\n","declarations":[{"children":[{"comments":null,"title":"Non","info":{"arguments":[],"declType":"dataConstructor"},"sourceSpan":null},{"comments":null,"title":"One","info":{"arguments":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"declType":"dataConstructor"},"sourceSpan":null},{"comments":null,"title":"Eno","info":{"arguments":[{"annotation":[],"tag":"TypeVar","contents":"b"}],"declType":"dataConstructor"},"sourceSpan":null},{"comments":null,"title":"Two","info":{"arguments":[{"annotation":[],"tag":"TypeVar","contents":"a"},{"annotation":[],"tag":"TypeVar","contents":"b"}],"declType":"dataConstructor"},"sourceSpan":null},{"comments":null,"title":"eqCan","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Eq"],"Eq"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null},{"constraintAnn":[],"constraintClass":[["Data","Eq"],"Eq"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"b"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Eq"],"Eq"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}},"sourceSpan":{"start":[47,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[47,54]}},{"comments":null,"title":"ordCan","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Ord"],"Ord"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null},{"constraintAnn":[],"constraintClass":[["Data","Ord"],"Ord"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"b"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Ord"],"Ord"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}},"sourceSpan":{"start":[48,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[48,58]}},{"comments":null,"title":"genericCan","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Generic","Rep"],"Generic"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeWildcard","contents":null}]}},"sourceSpan":{"start":[49,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[49,50]}},{"comments":null,"title":"functorCan","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Functor"],"Functor"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[50,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[50,46]}},{"comments":null,"title":"semigroupCan","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null},{"constraintAnn":[],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"b"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Semigroup"],"Semigroup"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}},"sourceSpan":{"start":[52,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[64,39]}},{"comments":null,"title":"monoidCan","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null},{"constraintAnn":[],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"b"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Monoid"],"Monoid"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}},"sourceSpan":{"start":[66,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[67,15]}},{"comments":null,"title":"bifunctorCan","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Bifunctor"],"Bifunctor"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]}]}},"sourceSpan":{"start":[69,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[74,31]}},{"comments":null,"title":"biApplyCan","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Biapply"],"Biapply"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]}]}},"sourceSpan":{"start":[76,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[81,28]}},{"comments":null,"title":"biApplicativeCan","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Biapplicative"],"Biapplicative"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]}]}},"sourceSpan":{"start":[83,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[84,15]}},{"comments":null,"title":"bifoldableCan","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Bifoldable"],"Bifoldable"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]}]}},"sourceSpan":{"start":[86,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[94,39]}},{"comments":null,"title":"bitraversableCan","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Bitraversable"],"Bitraversable"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]}]}},"sourceSpan":{"start":[96,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[103,33]}},{"comments":null,"title":"applyCan","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Apply"],"Apply"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[105,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[115,43]}},{"comments":null,"title":"applicativeCan","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Applicative"],"Applicative"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[117,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[118,13]}},{"comments":null,"title":"bindCan","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Bind"],"Bind"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[120,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[129,32]}},{"comments":null,"title":"monadCan","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Monad"],"Monad"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[131,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[131,50]}},{"comments":null,"title":"foldableCan","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Foldable"],"Foldable"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[133,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[136,31]}},{"comments":null,"title":"traversableCan","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Traversable"],"Traversable"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[138,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[140,29]}}],"comments":"`Can` 'a' 'b' can hold either no values, an 'a', a 'b', or both an 'a' and\na 'b'. The type is isomorphic with 'Maybe (Either (Either a b) (Tuple a b))'.\n","title":"Can","info":{"declType":"data","dataDeclType":"data","typeArguments":[["a",null],["b",null]]},"sourceSpan":{"start":[41,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[45,12]}},{"children":[],"comments":"Constructs a 'Can' given an isomorphic representation. Note that this is\nthe precise inverse of 'toRepr'.\n\n> fromRepr Nothing :: Can String Int\nNon\n> fromRepr (Just (Left (Left \"hello\"))) :: Can String Int\nOne \"hello\"\n> fromRepr (Just (Left (Right 42))) :: Can String Int\nEno 42\n> fromRepr (Just (Right (Tuple \"hello\" 42))) :: Can String Int\nTwo \"hello\" 42\n","title":"fromRepr","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Either"],"Either"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Either"],"Either"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},null]},null]}},"sourceSpan":{"start":[153,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[153,75]}},{"children":[],"comments":"Destructs a 'Can' to its isomorphic representation. Note that this is\nthe precise inverse of 'fromRepr'.\n\n> toRepr (Non :: Can String Int)\nNothing\n> toRepr (One \"hello\" :: Can String Int)\nJust (Left (Left \"hello\"))\n> toRepr (Eno 42 :: Can String Int)\nJust (Left (Right 42))\n> toRepr Two \"hello\" 42\nJust (Right (Tuple \"hello\" 42))\n","title":"toRepr","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Either"],"Either"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Either"],"Either"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}}]}]},null]},null]}},"sourceSpan":{"start":[171,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[171,73]}},{"children":[],"comments":"Construct a 'Can' from a pair of 'Maybe's.\n\n> fromMaybe Nothing Nothing :: Can String Int\nNon\n> fromMaybe (Just \"hello\") Nothing :: Can String Int\nOne \"hello\"\n> fromMaybe Nothing (Just 42) :: Can String Int\nEno 42\n> fromMaybe (Just \"hello\") (Just 42) :: Can String Int\nTwo \"hello\" 42\n","title":"fromMaybe","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}]},null]},null]}},"sourceSpan":{"start":[188,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[188,55]}},{"children":[],"comments":"'Can' catamorphism (fold). Takes an input for each possible constructor and\ntranslates it to 'c'.\n\nFor example, we can go from some 'c :: Can a b' to a\n'Maybe (Either (Either a b) (Tuple a b))' using:\n\n> can Nothing (Left <<< Left) (Left <<< Right) (\\a b -> Right (Tuple a b)) (Non :: Can String Int)\nNothing\n> can Nothing (Left <<< Left) (Left <<< Right) (\\a b -> Right (Tuple a b)) (One \"hello\" :: Can String Int)\nJust (Left (Left \"hello\"))\n> can Nothing (Left <<< Left) (Left <<< Right) (\\a b -> Right (Tuple a b)) (Eno 42 :: Can String Int)\nJust (Left (Right 42))\n> can Nothing (Left <<< Left) (Left <<< Right) (\\a b -> Right (Tuple a b)) (Two \"hello\" 42 :: Can String Int)\nJust (Right (Tuple \"hello\" 42))\n","title":"can","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"c"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[209,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[209,80]}},{"children":[],"comments":"Grabs an 'a' if it exists, otherwise returns nothing. Note that this\nfunction grabs an 'a' from either the `One` or the `Two` constructors.\n\n> first (Non :: Can String Int)\nNothing\n> first (One \"hello\" :: Can String Int)\nJust \"hello\"\n> first (Eno 42 :: Can String Int)\nNothing\n> first (Two \"hello\" 42)\nJust \"hello\"\n","title":"first","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},null]},null]}},"sourceSpan":{"start":[227,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[227,40]}},{"children":[],"comments":"Grabs an 'b' if it exists, otherwise returns nothing. Note that this\nfunction grabs a 'b' from either the `Eno` or the `Two` constructors.\n\n> second (Non :: Can String Int)\nNothing\n> second (One \"hello\" :: Can String Int)\nNothing\n> second (Eno 42 :: Can String Int)\nJust 42\n> second (Two \"hello\" 42)\nJust 42\n","title":"second","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},null]},null]}},"sourceSpan":{"start":[241,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[241,41]}},{"children":[],"comments":"Grabs both an 'a' and a 'b' if they both exist, from the `Two` constructor.\n\n> both (Non :: Can String Int)\nNothing\n> both (One \"hello\" :: Can String Int)\nNothing\n> both (Eno 42 :: Can String Int)\nNothing\n> both (Two \"hello\" 42)\nJust (Tuple \"hello\" 42)\n","title":"both","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]},null]},null]}},"sourceSpan":{"start":[254,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[254,49]}},{"children":[],"comments":"Checks if the constructor is `Non`.\n\n> isNone (Non :: Can String Int)\ntrue\n> isNone (One \"hello\" :: Can String Int)\nfalse\n> isNone (Eno 42 :: Can String Int)\nfalse\n> isNone (Two \"hello\" 42)\nfalse\n","title":"isNone","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]},null]},null]}},"sourceSpan":{"start":[267,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[267,41]}},{"children":[],"comments":"Checks if the constructor is `One`.\n\n> isOne (Non :: Can String Int)\nfalse\n> isOne (One \"hello\" :: Can String Int)\ntrue\n> isOne (Eno 42 :: Can String Int)\nfalse\n> isOne (Two \"hello\" 42)\nfalse\n","title":"isOne","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]},null]},null]}},"sourceSpan":{"start":[280,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[280,40]}},{"children":[],"comments":"Checks if the constructor is `Eno`.\n\n> isEno (Non :: Can String Int)\nfalse\n> isEno (One \"hello\" :: Can String Int)\nfalse\n> isEno (Eno 42 :: Can String Int)\ntrue\n> isEno (Two \"hello\" 42)\nfalse\n","title":"isEno","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]},null]},null]}},"sourceSpan":{"start":[293,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[293,40]}},{"children":[],"comments":"Checks if the constructor is `Two`.\n\n> isTwo (Non :: Can String Int)\nfalse\n> isTwo (One \"hello\" :: Can String Int)\nfalse\n> isTwo (Eno 42 :: Can String Int)\nfalse\n> isTwo (Two \"hello\" 42)\ntrue\n","title":"isTwo","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]},null]},null]}},"sourceSpan":{"start":[306,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[306,40]}},{"children":[],"comments":"Takes all 'a' values from a `Foldable` `Can`. Note that values are extracted\nfrom both the `One` and `Two` constructors.\n\n> ones [Non :: Can String Int]\nNil\n> ones ([One \"hello\", One \"world\"] :: Array (Can String Int))\nCons \"hello\" (Cons \"world\" Nil)\n> ones ([Eno 42, Eno 13] :: Array (Can String Int))\nNil\n> ones ([Two \"hello\" 42, Two \"world\" 1] :: Array (Can String Int))\nCons \"hello\" (Cons \"world\" Nil)\n> ones [One \"hello\", Eno 42, Two \"world\" 13]\nCons \"hello\" (Cons \"world\" Nil)\n","title":"ones","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["f",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Functor"],"Functor"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintData":null},{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Foldable"],"Foldable"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"List"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[322,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[322,71]}},{"children":[],"comments":"Takes all 'b' values from a `Foldable` `Can`. Note that values are extracted\nfrom both the `Eno` and `Two` constructors.\n\n> enos [Non :: Can String Int]\nNil\n> enos ([One \"hello\", One \"world\"] :: Array (Can String Int))\nNil\n> enos ([Eno 42, Eno 13] :: Array (Can String Int))\nCons 42 (Cons 13 Nil)\n> enos ([Two \"hello\" 42, Two \"world\" 13] :: Array (Can String Int))\nCons 42 (Cons 13 Nil)\n> enos [One \"hello\", Eno 42, Two \"world\" 13]\nCons 42 (Cons 13 Nil)\n","title":"enos","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["f",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Functor"],"Functor"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintData":null},{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Foldable"],"Foldable"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"List"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[338,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[338,71]}},{"children":[],"comments":"Takes all 'a' and 'b' values from a `Foldable` `Can`. Note that values are\nonly extracted from the `Two` constructor.\n\n> twos [Non :: Can String Int]\nNil\n> twos ([One \"hello\", One \"world\"] :: Array (Can String Int))\nNil\n> twos ([Eno \"hello\", Eno \"world\"] :: Array (Can String Int))\nNil\n> twos ([Two \"hello\" 42, Two \"world\" 1] :: Array (Can String Int))\nCons (Tuple \"hello\" 42) (Cons (Tuple \"world\" 1) Nil)\n","title":"twos","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["f",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Functor"],"Functor"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintData":null},{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Foldable"],"Foldable"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"List"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[352,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[352,81]}},{"children":[],"comments":"Expand a 'Can a b' to a 'Maybe a' and a 'Maybe b'. Note that the tuple\n'Tuple (Maybe a) (Maybe b)' is exactly equivalent with 'Can a b':\n\n- Nothing, Nothing ~ Non\n- Just a , Nothing ~ One a\n- Nothing, Just b  ~ Eno b\n- Just a , Just b  ~ Two a b\n","title":"curry","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[362,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[362,77]}},{"children":[],"comments":"Contract a 'Maybe a' and a 'Maybe b' to a 'Can a b'. Note that 'Can a b'\nis exactly equivalent with 'Tuple (Maybe a) (Maybe b)':\n\n- Non     ~ Nothing, Nothing\n- One a   ~ Just a , Nothing\n- Eno b   ~ Nothing, Just b\n- Two a b ~ Just a , Just b\n","title":"uncurry","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[376,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[376,79]}},{"children":[],"comments":"Grab all 'a' and 'b' values from a `Foldable` 'Can a b' and combine them\neach into an `Alternative` 'f' tuple.\n\n> partition [Non, One \"hello\", Eno 42, Two \"world\" 1] :: Tuple (List String) (List Int)\nTuple (Cons \"hello\" (Cons \"world\" Nil)) (Cons 42 (Cons 1 Nil))\n","title":"partition","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["t",{"annotation":[],"tag":"ForAll","contents":["f",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Foldable"],"Foldable"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"t"}],"constraintData":null},{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Control","Alternative"],"Alternative"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"t"},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]}]}]},null]},null]},null]},null]}},"sourceSpan":{"start":[388,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[393,23]}},{"children":[],"comments":"Maps 'Can's over a `Traversable` and partitions the values by their\nposition in the 'Can'.\n\n> partitionMap (\\i -> if i < 3 then One i else Eno i) [1, 2, 3, 4, 5] :: Tuple (Array Int) (Array Int)\nTuple [1, 2] [3, 4, 5]\n","title":"partitionMap","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["t",{"annotation":[],"tag":"ForAll","contents":["f",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Control","Alternative"],"Alternative"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintData":null},{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Traversable"],"Traversable"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"t"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"t"},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]}]}]}]}]},null]},null]},null]},null]},null]}},"sourceSpan":{"start":[408,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[414,23]}},{"children":[],"comments":"Distribute 'Can' over a 'Tuple'.\n\n> distribute (Non :: Can (Tuple String String) Int)\nTuple Non Non\n> distribute (One (Tuple \"hello\" \"world\") :: Can (Tuple String String) Int)\nTuple (One \"hello\") (One \"world\")\n> distribute (Eno 42 :: Can (Tuple String String) Int)\nTuple (Eno 42) (Eno 42)\n> distribute (Two (Tuple \"hello\" \"world\") 42 :: Can (Tuple String String) Int)\nTuple (Two \"hello\" 42) (Two \"world\" 42)\n","title":"distribute","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]}]},null]},null]},null]}},"sourceSpan":{"start":[434,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[434,75]}},{"children":[],"comments":"Codistribute 'Either' over a 'Can'.\n\n> codistribute (Left Non :: Either (Can String Int) (Can Boolean Int))\nNon\n> codistribute (Left (One \"hello\") :: Either (Can String Int) (Can Boolean Int))\nOne (Left \"hello\")\n> codistribute (Left (Eno 42) :: Either (Can String Int) (Can Boolean Int))\nEno 42\n> codistribute (Left (Two \"hello\" 42) :: Either (Can String Int) (Can Boolean Int))\nTwo (Left \"hello\") 42\n> codistribute (Right Non :: Either (Can String Int) (Can Boolean Int))\nNon\n> codistribute (Right (One true) :: Either (Can String Int) (Can Boolean Int))\nOne (Right true)\n> codistribute (Right (Eno 42) :: Either (Can String Int) (Can Boolean Int))\nEno 42\n> codistribute (Right (Two true 42) :: Either (Can String Int) (Can Boolean Int))\nTwo (Right true) 42\n","title":"codistribute","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Either"],"Either"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Either"],"Either"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]},null]},null]},null]}},"sourceSpan":{"start":[459,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[459,79]}},{"children":[],"comments":"Reassociates a `Can` from left to right.\nNote that 'Eno c' and 'Two Non c' both collapse to 'Eno (Eno c)', so\nit is NOT the case that 'reassocLR <<< reassocRL = identity'.\n","title":"reassocLR","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]}]},null]},null]},null]}},"sourceSpan":{"start":[468,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[468,62]}},{"children":[],"comments":"Reassociates a `Can` from right to left.\nNote that 'Eno c' and 'Two Non c' both collapse to 'Eno (Eno c)', so\nit is NOT the case that 'reassocLR <<< reassocRL = identity'.\n","title":"reassocRL","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]},null]},null]},null]}},"sourceSpan":{"start":[484,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[484,62]}},{"children":[],"comments":"Swap the inputs for a 'Can'.\n\n> swap (Non :: Can String Int)\nNon\n> swap (One \"hello\" :: Can String Int)\nEno \"hello\"\n> swap (Eno 42 :: Can String Int)\nOne 42\n> swap (Two \"hello\" 42)\nTwo 42 \"hello\"\n","title":"swap","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},null]},null]}},"sourceSpan":{"start":[507,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Can.purs","end":[507,39]}}]},{"reExports":[],"name":"Data.Pointed.Convert","comments":"This module defines conversion functions between Can, Smash, and Wedge.\n\nThe examples assume that the pointed modules are imported qualified:\n> import Data.Pointed.Can as C\n> import Data.Pointed.Smash as S\n> import Data.Pointed.Wedge as W\n","declarations":[{"children":[],"comments":"Convert from 'Can' to 'Wedge'.\n\n> canSmash (C.Non :: Can String Int)\nS.Non\n> canSmash (C.One \"hello\" :: Can String Int)\nS.Non\n> canSmash (C.Eno 42 :: Can String Int)\nS.Non\n> canSmash (C.Two \"hello\" 42 :: Can String Int)\nS.Two \"hello\" 42\n","title":"canSmash","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},null]},null]}},"sourceSpan":{"start":[28,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Convert.purs","end":[28,45]}},{"children":[],"comments":"Convert from 'Wedge' to 'Can'.\n\n> smashCan (S.Non :: Smash String Int)\nC.Non\n> smashCan (S.Two \"hello\" 42 :: Smash String Int)\nC.Two \"hello\" 42\n","title":"smashCan","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},null]},null]}},"sourceSpan":{"start":[37,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Convert.purs","end":[37,45]}},{"children":[],"comments":"Convert from 'Can' to 'Wedge'.\n\n> canWedge (C.Non :: Can String Int)\nW.Non\n> canWedge (C.One \"hello\" :: Can String Int)\nW.One \"hello\"\n> canWedge (C.Eno 42 :: Can String Int)\nW.Eno 42\n> canWedge (C.Two \"hello\" 42 :: Can String Int)\nW.Non\n","title":"canWedge","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},null]},null]}},"sourceSpan":{"start":[50,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Convert.purs","end":[50,45]}},{"children":[],"comments":"Convert from 'Wedge' to 'Can'.\n\n> wedgeCan (W.Non :: Wedge String Int)\nC.Non\n> wedgeCan (W.One \"hello\" :: Wedge String Int)\nC.One \"hello\"\n> wedgeCan (W.Eno 42 :: Wedge String Int)\nC.Eno 42\n","title":"wedgeCan","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},null]},null]}},"sourceSpan":{"start":[61,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Convert.purs","end":[61,45]}},{"children":[],"comments":"Convert from 'Wedge' to 'Smash', given default values for 'a' and 'b'.\n\n> hulkSmash \"world\" 1 (W.Non :: Wedge String Int)\nS.Non\n> hulkSmash \"world\" 1 (W.One \"hello\" :: Wedge String Int)\nS.Two \"hello\" 1\n> hulkSmash \"world\" 1 (W.Eno 42 :: Wedge String Int)\nC.Eno \"world\" 42\n","title":"hulkSmash","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}]}]},null]},null]}},"sourceSpan":{"start":[72,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Convert.purs","end":[72,58]}}]},{"reExports":[],"name":"Data.Pointed.Distributivity","comments":"This module defines distributivity laws between Can, Smash, and Wedge.\n","declarations":[{"children":[],"comments":null,"title":"smashWedge","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]}]},null]},null]},null]}},"sourceSpan":{"start":[15,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Distributivity.purs","end":[15,81]}},{"children":[],"comments":null,"title":"wedgeSmash","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]},null]},null]},null]}},"sourceSpan":{"start":[21,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Distributivity.purs","end":[21,81]}},{"children":[],"comments":null,"title":"smashTuple","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]}]},null]},null]},null]}},"sourceSpan":{"start":[27,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Distributivity.purs","end":[27,81]}},{"children":[],"comments":null,"title":"tupleSmash","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]},null]},null]},null]}},"sourceSpan":{"start":[33,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Distributivity.purs","end":[33,81]}},{"children":[],"comments":null,"title":"smashCan","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]}]},null]},null]},null]}},"sourceSpan":{"start":[38,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Distributivity.purs","end":[38,75]}},{"children":[],"comments":null,"title":"canSmash","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Can"],"Can"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]},null]},null]},null]}},"sourceSpan":{"start":[43,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Distributivity.purs","end":[43,75]}}]},{"reExports":[],"name":"Data.Pointed.Smash","comments":"This module defines the `Smash` type, along with instances and functions that\nhelp use this type. Generally, 'Smash' is used when the data is isomorphic\nto 'Maybe (Tuple a b)'.\n\nWe can map over both arguments using `bimap`:\n\n> bimap show (_ + 10) (Non :: Smash Int Int)\nNon\n> bimap show (_ + 10) (Two 42 1 :: Smash Int Int)\nTwo \"42\" 11\n","declarations":[{"children":[{"comments":null,"title":"Non","info":{"arguments":[],"declType":"dataConstructor"},"sourceSpan":null},{"comments":null,"title":"Two","info":{"arguments":[{"annotation":[],"tag":"TypeVar","contents":"a"},{"annotation":[],"tag":"TypeVar","contents":"b"}],"declType":"dataConstructor"},"sourceSpan":null},{"comments":null,"title":"eqSmash","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Eq"],"Eq"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null},{"constraintAnn":[],"constraintClass":[["Data","Eq"],"Eq"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"b"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Eq"],"Eq"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}},"sourceSpan":{"start":[34,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Smash.purs","end":[34,58]}},{"comments":null,"title":"ordSmash","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Ord"],"Ord"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null},{"constraintAnn":[],"constraintClass":[["Data","Ord"],"Ord"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"b"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Ord"],"Ord"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}},"sourceSpan":{"start":[35,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Smash.purs","end":[35,62]}},{"comments":null,"title":"genericSmash","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Generic","Rep"],"Generic"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeWildcard","contents":null}]}},"sourceSpan":{"start":[36,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Smash.purs","end":[36,54]}},{"comments":null,"title":"functorSmash","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Functor"],"Functor"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[37,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Smash.purs","end":[37,50]}},{"comments":null,"title":"semigroupSmash","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null},{"constraintAnn":[],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"b"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Semigroup"],"Semigroup"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}},"sourceSpan":{"start":[39,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Smash.purs","end":[43,54]}},{"comments":null,"title":"monoidSmash","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null},{"constraintAnn":[],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"b"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Monoid"],"Monoid"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}},"sourceSpan":{"start":[45,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Smash.purs","end":[46,15]}},{"comments":null,"title":"bifunctorSmash","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Bifunctor"],"Bifunctor"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]}]}},"sourceSpan":{"start":[48,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Smash.purs","end":[51,31]}},{"comments":null,"title":"biapplySmash","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Biapply"],"Biapply"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]}]}},"sourceSpan":{"start":[53,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Smash.purs","end":[56,27]}},{"comments":null,"title":"biapplicativeSmash","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Biapplicative"],"Biapplicative"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]}]}},"sourceSpan":{"start":[58,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Smash.purs","end":[59,15]}},{"comments":null,"title":"bifoldableSmash","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Bifoldable"],"Bifoldable"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]}]}},"sourceSpan":{"start":[61,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Smash.purs","end":[67,39]}},{"comments":null,"title":"bitraversableSmash","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Bitraversable"],"Bitraversable"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]}]}},"sourceSpan":{"start":[69,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Smash.purs","end":[74,33]}},{"comments":null,"title":"applySmash","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Apply"],"Apply"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[76,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Smash.purs","end":[79,30]}},{"comments":null,"title":"applicativeSmash","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Monoid"],"Monoid"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Applicative"],"Applicative"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[81,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Smash.purs","end":[82,20]}},{"comments":null,"title":"bindSmash","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Monoid"],"Monoid"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Bind"],"Bind"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[84,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Smash.purs","end":[89,35]}},{"comments":null,"title":"monadSmash","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Monoid"],"Monoid"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Monad"],"Monad"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[91,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Smash.purs","end":[91,51]}},{"comments":null,"title":"foldableSmash","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Foldable"],"Foldable"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[93,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Smash.purs","end":[97,31]}},{"comments":null,"title":"traversableSmash","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Traversable"],"Traversable"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[99,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Smash.purs","end":[101,29]}}],"comments":"`Smash` 'a' 'b' can hold either no values or an 'a' and a 'b'.  The type is\nisomorphic with 'Maybe (Tuple a b)'.\n","title":"Smash","info":{"declType":"data","dataDeclType":"data","typeArguments":[["a",null],["b",null]]},"sourceSpan":{"start":[30,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Smash.purs","end":[32,12]}},{"children":[],"comments":"Constructs a 'Smash' given an isomorphic representation. Note that this is\nthe precise inverse of 'toMaybe'.\n\n> fromMaybe Nothing :: Smash String Int\nNon\n> fromMaybe (Just (Tuple \"hello\" 42)) :: Smash String Int\nTwo \"hello\" 42\n","title":"fromMaybe","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},null]},null]}},"sourceSpan":{"start":[110,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Smash.purs","end":[110,56]}},{"children":[],"comments":"Destructs a 'Smash' from an isomorphic representation. Note that this is\nthe precise inverse of 'fromMaybe'.\n\n> toMaybe Non :: Smash String Int\nNothing\n> toMaybe (Two \"hello\" 42 :: Smash String Int)\nJust (Tuple \"hello\" 42)\n","title":"toMaybe","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]},null]},null]}},"sourceSpan":{"start":[120,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Smash.purs","end":[120,54]}},{"children":[],"comments":"'Smash' catamorphism (fold). Takes an input for each possible constructor and\ntranslates it to 'c'.\n\nFor example, we can go from some 's :: Smash a b' to a\n'Maybe (Tuple a b)' using:\n\n> smash Nothing (\\a b -> Just (Tuple a b)) (Non :: Smash String Int)\nNothing\n> smash Nothing (\\a b -> Just (Tuple a b)) (Two \"hello\" 43 :: Smash String Int)\nJust (Tuple \"hello\" 42)\n","title":"smash","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"c"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[133,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Smash.purs","end":[133,60]}},{"children":[],"comments":"Grabs an 'a' if it exists, otherwise returns nothing.\n\n> first (Non :: Smash String Int)\nNothing\n> first (Two \"hello\" 42 :: Smash String Int)\nJust \"hello\"\n","title":"first","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},null]},null]}},"sourceSpan":{"start":[144,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Smash.purs","end":[144,42]}},{"children":[],"comments":"Grabs a 'b' if it exists, otherwise returns nothing.\n\n> second (Non :: Smash String Int)\nNothing\n> second (Two \"hello\" 42 :: Smash String Int)\nJust 42\n","title":"second","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},null]},null]}},"sourceSpan":{"start":[153,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Smash.purs","end":[153,43]}},{"children":[],"comments":"Grabs an 'a' and a 'b' if they exist, otherwise returns nothing.\n\n> second (Non :: Smash String Int)\nNothing\n> second (Two \"hello\" 42 :: Smash String Int)\nJust (Tuple \"hello\" 42)\n","title":"both","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]},null]},null]}},"sourceSpan":{"start":[162,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Smash.purs","end":[162,51]}},{"children":[],"comments":"Checks if the constructor is `Non`.\n\n> isNone (Non :: Smash String Int)\ntrue\n> isNone (Two \"hello\" 42 :: Smash String Int)\nfalse\n","title":"isNone","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]},null]},null]}},"sourceSpan":{"start":[171,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Smash.purs","end":[171,43]}},{"children":[],"comments":"Checks if the constructor is `Two`.\n\n> isNone (Non :: Smash String Int)\nfalse\n> isNone (Two \"hello\" 42 :: Smash String Int)\ntrue\n","title":"isTwo","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]},null]},null]}},"sourceSpan":{"start":[180,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Smash.purs","end":[180,42]}},{"children":[],"comments":"Takes all 'a' and 'b' values from a `Foldable` `Smash`.\n\n> twos [Non :: Smash String Int]\nNil\n> twos ([Two \"hello\" 42, Non, Two \"world\" 1] :: Array (Smash String Int))\nCons (Tuple \"hello\" 42) (Cons (Tuple \"world\" 1) Nil)\n","title":"twos","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["f",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Functor"],"Functor"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintData":null},{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Foldable"],"Foldable"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"List"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[189,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Smash.purs","end":[189,83]}},{"children":[],"comments":"Expand a 'Smash a b' to a 'Maybe a' and a 'Maybe b'. Note that the tuple\n'Tuple (Maybe a) (Maybe b)' has more information that we can store in a\n'Smash a b'.\n\n- Nothing, Nothing ~ Non\n- Just a , Nothing ~ Non\n- Nothing, Just b  ~ Non\n- Just a , Just b  ~ Two a b\n","title":"curry","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[200,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Smash.purs","end":[200,79]}},{"children":[],"comments":"Contract a 'Smash a b' to a 'Maybe a' and a 'Maybe b'. Note that the tuple\n'Tuple (Maybe a) (Maybe b)' has more information that we can store in a\n'Smash a b'.\n\nNon     ~ Nothing, Nothing\nTwo a b ~ Just a , Just b\n","title":"uncurry","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[211,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Smash.purs","end":[211,81]}},{"children":[],"comments":"Grab all 'a' and 'b' values from a `Foldable` 'Smash a b' and combine them\neach into an `Alternative` 'f' tuple.\n\n> partition [Non, Two \"hello\" 42, Two \"world\" 1] :: Tuple (List String) (List Int)\nTuple (Cons \"hello\" (Cons \"world\" Nil)) (Cons 42 (Cons 1 Nil))\n","title":"partition","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["t",{"annotation":[],"tag":"ForAll","contents":["f",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Foldable"],"Foldable"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"t"}],"constraintData":null},{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Control","Alternative"],"Alternative"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"t"},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]}]}]},null]},null]},null]},null]}},"sourceSpan":{"start":[221,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Smash.purs","end":[226,23]}},{"children":[],"comments":"Maps 'Smash'es over a `Traversable` and partitions the values by their\nposition in the 'Smash'.\n\n> partitionMap (\\i -> if i < 3 then Non else Two i (i*10)) [1, 2, 3, 4, 5] :: Tuple (Array Int) (Array Int)\nTuple [3, 4, 5] [30, 40, 50]\n","title":"partitionMap","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["t",{"annotation":[],"tag":"ForAll","contents":["f",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Control","Alternative"],"Alternative"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintData":null},{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Traversable"],"Traversable"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"t"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"t"},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]}]}]}]}]},null]},null]},null]},null]},null]}},"sourceSpan":{"start":[239,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Smash.purs","end":[245,23]}},{"children":[],"comments":"Reassociates a `Smash` from left to right.\nNote that 'Non' and 'Two Non c' both collapse to 'Non', so\nit is NOT the case that 'reassocLR <<< reassocRL = identity'.\n","title":"reassocLR","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]}]},null]},null]},null]}},"sourceSpan":{"start":[256,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Smash.purs","end":[256,70]}},{"children":[],"comments":"Reassociates a `Smash` from right to left.\nNote that 'Non' and 'Two Non c' both collapse to 'Non', so\nit is NOT the case that 'reassocLR <<< reassocRL = identity'.\n","title":"reassocRL","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]},null]},null]},null]}},"sourceSpan":{"start":[264,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Smash.purs","end":[264,70]}},{"children":[],"comments":"Swap the inputs for a 'Smash'.\n\n> swap (Non :: Smash String Int)\nNon\n> swap (Two \"hello\" 42)\nTwo 42 \"hello\"\n","title":"swap","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Smash"],"Smash"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},null]},null]}},"sourceSpan":{"start":[275,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Smash.purs","end":[275,43]}}]},{"reExports":[],"name":"Data.Pointed.Wedge","comments":"This module defines the `Wedge` type, along with instances and functions that\nhelp use this type. Generally, 'Wedge' is used when the data is more vague\nthan simply using 'Either a b', i.e. when either or both 'a' and 'b' might\nbe missing.\n\nThe `Semigroup` instance may lose information (biased towards 'Eno'):\n\n> (One \"hello\" :: Wedge String Int) <> (Eno 42 :: Wedge String Int)\nEno 42\n\nWe can map over both arguments using `bimap`:\n\n> bimap show (_ + 10) (Non :: Wedge Int Int)\nNon\n> bimap show (_ + 10) (One 42 :: Wedge Int Int)\nOne \"42\"\n> bimap show (_ + 10) (Eno 1 :: Wedge Int Int)\nOne 11\n","declarations":[{"children":[{"comments":null,"title":"Non","info":{"arguments":[],"declType":"dataConstructor"},"sourceSpan":null},{"comments":null,"title":"One","info":{"arguments":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"declType":"dataConstructor"},"sourceSpan":null},{"comments":null,"title":"Eno","info":{"arguments":[{"annotation":[],"tag":"TypeVar","contents":"b"}],"declType":"dataConstructor"},"sourceSpan":null},{"comments":null,"title":"eqWedge","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Eq"],"Eq"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null},{"constraintAnn":[],"constraintClass":[["Data","Eq"],"Eq"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"b"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Eq"],"Eq"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}},"sourceSpan":{"start":[43,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Wedge.purs","end":[43,58]}},{"comments":null,"title":"ordWedge","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Ord"],"Ord"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null},{"constraintAnn":[],"constraintClass":[["Data","Ord"],"Ord"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"b"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Ord"],"Ord"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}},"sourceSpan":{"start":[44,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Wedge.purs","end":[44,62]}},{"comments":null,"title":"genericWedge","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Generic","Rep"],"Generic"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeWildcard","contents":null}]}},"sourceSpan":{"start":[45,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Wedge.purs","end":[45,54]}},{"comments":null,"title":"functorWedge","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Functor"],"Functor"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[46,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Wedge.purs","end":[46,50]}},{"comments":null,"title":"semigroupWedge","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null},{"constraintAnn":[],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"b"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Semigroup"],"Semigroup"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}},"sourceSpan":{"start":[48,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Wedge.purs","end":[55,37]}},{"comments":null,"title":"monoidWedge","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null},{"constraintAnn":[],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"b"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Monoid"],"Monoid"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}},"sourceSpan":{"start":[58,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Wedge.purs","end":[59,15]}},{"comments":null,"title":"bifunctorWedge","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Bifunctor"],"Bifunctor"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]}]}},"sourceSpan":{"start":[61,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Wedge.purs","end":[65,23]}},{"comments":null,"title":"biapplyWedge","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Biapply"],"Biapply"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]}]}},"sourceSpan":{"start":[67,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Wedge.purs","end":[71,23]}},{"comments":null,"title":"bifoldableWedge","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Bifoldable"],"Bifoldable"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]}]}},"sourceSpan":{"start":[73,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Wedge.purs","end":[80,39]}},{"comments":null,"title":"bitraversableWedge","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Bitraversable"],"Bitraversable"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]}]}},"sourceSpan":{"start":[82,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Wedge.purs","end":[88,33]}},{"comments":null,"title":"applyWedge","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Apply"],"Apply"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[90,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Wedge.purs","end":[96,30]}},{"comments":null,"title":"applicativeWedge","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Monoid"],"Monoid"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Applicative"],"Applicative"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[98,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Wedge.purs","end":[99,13]}},{"comments":null,"title":"bindWedge","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Monoid"],"Monoid"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Bind"],"Bind"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[101,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Wedge.purs","end":[105,17]}},{"comments":null,"title":"monadWedge","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Monoid"],"Monoid"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Monad"],"Monad"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[107,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Wedge.purs","end":[107,51]}},{"comments":null,"title":"foldableWedge","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Foldable"],"Foldable"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[109,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Wedge.purs","end":[113,31]}},{"comments":null,"title":"traversableWedge","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Traversable"],"Traversable"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[115,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Wedge.purs","end":[117,29]}}],"comments":"`Wedge` 'a' 'b' can hold either no values, an 'a', or a 'b'.  The type is\nisomorphic with 'Maybe (Either a b)'.\n","title":"Wedge","info":{"declType":"data","dataDeclType":"data","typeArguments":[["a",null],["b",null]]},"sourceSpan":{"start":[38,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Wedge.purs","end":[41,10]}},{"children":[],"comments":"Constructs a 'Wedge' given an isomorphic representation. Note that this is\nthe precise inverse of 'toMaybeEither'.\n\n> fromMaybeEither Nothing :: Wedge String Int\nNon\n> fromMaybeEither (Just (Left \"hello\")) :: Wedge String Int\nOne \"hello\"\n> fromMaybeEither (Just (Right 42)) :: Wedge String Int\nEno 42\n","title":"fromMaybeEither","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Either"],"Either"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},null]},null]}},"sourceSpan":{"start":[128,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Wedge.purs","end":[128,63]}},{"children":[],"comments":"Destructs a 'Wedge' from an isomorphic representation. Note that this is\nthe precise inverse of 'fromMaybeEither'.\n\n> toMaybeEither (Non :: Wedge String Int)\nNothing\n> toMaybeEither (One \"hello\" :: Wedge String Int)\nJust (Left \"hello\")\n> toMaybeEither (Eno 42 :: Wedge String Int)\nJust (Right 42)\n","title":"toMaybeEither","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Either"],"Either"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]},null]},null]}},"sourceSpan":{"start":[140,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Wedge.purs","end":[140,61]}},{"children":[],"comments":"Constructs a 'Wedge' given an either of maybes. Note that this is\nthe precise inverse of 'toMaybeEither'.\n\n> fromEitherMaybe (Left Nothing) :: Wedge String Int\nNon\n> fromEitherMaybe (Left (Just \"hello\")) :: Wedge String Int\nOne \"hello\"\n> fromEitherMaybe (Right Nothing) :: Wedge String Int\nNon\n> fromEitherMaybe (Right (Just 42)) :: Wedge String Int\nEno 42\n","title":"fromEitherMaybe","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Either"],"Either"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},null]},null]}},"sourceSpan":{"start":[154,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Wedge.purs","end":[154,71]}},{"children":[],"comments":"Constructs a left-biased 'Wedge'.\n\n> fromMaybeOne Nothing :: Wedge String Int\nNon\n> fromMaybeOne (Just \"hello\") :: Wedge String Int\nOne \"hello\"\n","title":"fromMaybeOne","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},null]},null]}},"sourceSpan":{"start":[163,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Wedge.purs","end":[163,49]}},{"children":[],"comments":"Constructs a right-biased 'Wedge'.\n\n> fromMaybeTwo Nothing :: Wedge String Int\nNon\n> fromMaybeTwo (Just 42) :: Wedge String Int\nEno 42\n","title":"fromMaybeEno","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},null]},null]}},"sourceSpan":{"start":[172,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Wedge.purs","end":[172,49]}},{"children":[],"comments":"'Wedge' catamorphism (fold). Takes an input for each possible constructor and\ntranslates it to 'c'.\n\nFor example, we can go from some 'w :: Wedge a b' to a\n'Maybe (Either a b)' using:\n\n> wedge Nothing Left Right (Non :: Wedge String Int)\nNon\n> wedge Nothing Left Right (One \"hello\" :: Wedge String Int)\nJust (Left \"hello\")\n> wedge Nothing Left Right (Eno 42 :: Wedge String Int)\nJust (Right 42)\n","title":"wedge","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"c"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[187,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Wedge.purs","end":[187,67]}},{"children":[],"comments":"Grabs an 'a' if it exists, otherwise returns nothing.\n\n> first (Non :: Wedge String Int)\nNothing\n> first (One \"hello\" :: Wedge String Int)\nJust \"hello\"\n> first (Eno 42 :: Wedge String Int)\nNothing\n","title":"first","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},null]},null]}},"sourceSpan":{"start":[201,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Wedge.purs","end":[201,42]}},{"children":[],"comments":"Grabs a 'b' if it exists, otherwise returns nothing.\n\n> second (Non :: Wedge String Int)\nNothing\n> second (One \"hello\" :: Wedge String Int)\nNothing\n> second (Eno 42 :: Wedge String Int)\nJust 42\n","title":"second","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},null]},null]}},"sourceSpan":{"start":[212,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Wedge.purs","end":[212,43]}},{"children":[],"comments":"Checks if the constructor is `Non`.\n\n> isNone (Non :: Wedge String Int)\ntrue\n> isNone (One \"hello\" :: Wedge String Int)\nfalse\n> isNone (Eno 42 :: Wedge String Int)\nfalse\n","title":"isNone","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]},null]},null]}},"sourceSpan":{"start":[223,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Wedge.purs","end":[223,43]}},{"children":[],"comments":"Checks if the constructor is `One`.\n\n> isOne (Non :: Wedge String Int)\nfalse\n> isOne (One \"hello\" :: Wedge String Int)\ntrue\n> isOne (Eno 42 :: Wedge String Int)\nfalse\n","title":"isOne","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]},null]},null]}},"sourceSpan":{"start":[234,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Wedge.purs","end":[234,42]}},{"children":[],"comments":"Checks if the constructor is `Eno`.\n\n> isEno (Non :: Wedge String Int)\nfalse\n> isEno (One \"hello\" :: Wedge String Int)\nfalse\n> isEno (Eno 42 :: Wedge String Int)\ntrue\n","title":"isEno","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]},null]},null]}},"sourceSpan":{"start":[245,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Wedge.purs","end":[245,42]}},{"children":[],"comments":"Takes all 'a' values from a `Foldable` `Wedge`.\n\n> ones [Non :: Wedge String Int]\nNil\n> ones ([One \"hello\", One \"world\"] :: Array (Wedge String Int))\nCons \"hello\" (Cons \"world\" Nil)\n> ones ([Eno 42, Eno 13] :: Array (Wedge String Int))\nNil\n> ones ([One \"hello\", Eno 42] :: Array (Wedge String Int))\nCons \"hello\" Nil\n","title":"ones","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["f",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Functor"],"Functor"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintData":null},{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Foldable"],"Foldable"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"List"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[258,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Wedge.purs","end":[258,73]}},{"children":[],"comments":"Takes all 'b' values from a `Foldable` `Wedge`.\n\n> enos [Non :: Wedge String Int]\nNil\n> enos ([One \"hello\", One \"world\"] :: Array (Wedge String Int))\nNil\n> enos ([Eno 42, Eno 13] :: Array (Wedge String Int))\nCons 42 (Cons 13 Nil)\n> enos ([One \"hello\", Eno 42] :: Wedge String Int)\nCons 42 Nil\n","title":"enos","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["f",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Functor"],"Functor"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintData":null},{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Foldable"],"Foldable"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"List"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[271,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Wedge.purs","end":[271,73]}},{"children":[],"comments":"Grab all 'a' and 'b' values from a `Foldable` 'Wedge a b' and combine them\neach into an `Alternative` 'f' tuple.\n\n> partition [Non, One \"hello\", Eno 42] :: Tuple (List String) (List Int)\nTuple (Cons \"hello\" Nil) (Cons 42)\n","title":"partition","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["t",{"annotation":[],"tag":"ForAll","contents":["f",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Foldable"],"Foldable"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"t"}],"constraintData":null},{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Control","Alternative"],"Alternative"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"t"},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]}]}]},null]},null]},null]},null]}},"sourceSpan":{"start":[279,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Wedge.purs","end":[284,23]}},{"children":[],"comments":"Maps 'Wedge's over a `Traversable` and partitions the values by their\nposition in the 'Wedge'.\n\n> partitionMap (\\i -> if i < 3 then One i else Eno i) [1, 2, 3, 4, 5] :: Tuple (Array Int) (Array Int)\nTuple [1, 2] [3, 4, 5]\n","title":"partitionMap","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["t",{"annotation":[],"tag":"ForAll","contents":["f",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Control","Alternative"],"Alternative"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintData":null},{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Traversable"],"Traversable"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"t"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"t"},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]}]}]}]}]},null]},null]},null]},null]},null]}},"sourceSpan":{"start":[298,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Wedge.purs","end":[304,23]}},{"children":[],"comments":"Distribute 'Wedge' over a 'Tuple'.\n\n> distribute (Non :: Wedge (Tuple String String) Int)\nTuple Non Non\n> distribute (One (Tuple \"hello\" \"world\") :: Wedge (Tuple String String) Int)\nTuple (One \"hello\") (One \"world\")\n> distribute (Eno 42 :: Wedge (Tuple String String) Int)\nTuple (Eno 42) (Eno 42)\n","title":"distribute","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]}]},null]},null]},null]}},"sourceSpan":{"start":[321,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Wedge.purs","end":[321,81]}},{"children":[],"comments":"Codistribute 'Either' over a 'Wedge'.\n\n> codistribute (Left Non :: Either (Wedge String Int) (Wedge Boolean Int))\nNon\n> codistribute (Left (One \"hello\") :: Either (Wedge String Int) (Wedge Boolean Int))\nOne (Left \"hello\")\n> codistribute (Left (Eno 42) :: Either (Wedge String Int) (Wedge Boolean Int))\nEno 42\n> codistribute (Right Non :: Either (Wedge String Int) (Wedge Boolean Int))\nNon\n> codistribute (Right (One true) :: Either (Wedge String Int) (Wedge Boolean Int))\nOne (Right true)\n> codistribute (Right (Eno 42) :: Either (Wedge String Int) (Wedge Boolean Int))\nEno 42\n","title":"codistribute","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Either"],"Either"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Either"],"Either"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]},null]},null]},null]}},"sourceSpan":{"start":[341,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Wedge.purs","end":[341,85]}},{"children":[],"comments":"Reassociates a `Wedge` from left to right.\nNote that this is the inverse of 'reassocRL', i.e.:\n'reassocRL <<< reassocLR = identity'.\n","title":"reassocLR","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]}]},null]},null]},null]}},"sourceSpan":{"start":[350,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Wedge.purs","end":[350,70]}},{"children":[],"comments":"Reassociates a `Wedge` from right to left.\nNote that this is the inverse of 'reassocLR', i.e.:\n'reassocRL <<< reassocLR = identity'.\n","title":"reassocRL","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]},null]},null]},null]}},"sourceSpan":{"start":[361,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Wedge.purs","end":[361,70]}},{"children":[],"comments":"Swap the inputs for a 'Wedge'.\n\n> swap (Non :: Wedge String Int)\nNon\n> swap (One \"hello\" :: Wedge String Int)\nEno \"hello\"\n> swap (Eno 42 :: Wedge String Int)\nOne 42\n","title":"swap","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Pointed","Wedge"],"Wedge"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},null]},null]}},"sourceSpan":{"start":[377,1],"name":"/Users/lf33ge/code/pointed/src/Data/Pointed/Wedge.purs","end":[377,43]}}]}],"resolvedDependencies":{"purescript-newtype":"3.0.0","purescript-effect":"2.0.1","purescript-control":"4.2.0","purescript-either":"4.1.1","purescript-maybe":"4.0.1","purescript-type-equality":"3.0.0","purescript-distributive":"4.0.0","purescript-unfoldable":"4.1.0","purescript-invariant":"4.1.0","purescript-lazy":"4.0.0","purescript-foldable-traversable":"4.1.1","purescript-tailrec":"4.1.1","purescript-gen":"2.1.1","purescript-prelude":"4.1.1","purescript-bifunctors":"4.0.0","purescript-nonempty":"5.0.0","purescript-refs":"4.1.0","purescript-orders":"4.0.0","purescript-generics-rep":"6.1.1","purescript-enums":"4.0.1","purescript-tuples":"5.1.0","purescript-partial":"2.0.1","purescript-identity":"4.1.0","purescript-lists":"5.4.1"},"version":"0.1.0","github":["vladciobanu","purescript-pointed"],"versionTag":"v0.1.0","moduleMap":{"Data.BooleanAlgebra":"purescript-prelude","Data.Ring":"purescript-prelude","Data.NonEmpty":"purescript-nonempty","Effect.Uncurried":"purescript-effect","Effect":"purescript-effect","Data.Traversable.Accum.Internal":"purescript-foldable-traversable","Data.Enum.Gen":"purescript-enums","Data.Bifunctor.Flip":"purescript-bifunctors","Data.Ord":"purescript-prelude","Control.Monad.Gen":"purescript-gen","Type.Data.Row":"purescript-prelude","Data.Monoid.Dual":"purescript-prelude","Data.Generic.Rep.Ring":"purescript-generics-rep","Control.Monad.Rec.Class":"purescript-tailrec","Data.Bitraversable":"purescript-foldable-traversable","Data.Boolean":"purescript-prelude","Control.Biapplicative":"purescript-bifunctors","Data.Bounded":"purescript-prelude","Data.TraversableWithIndex":"purescript-foldable-traversable","Data.Show":"purescript-prelude","Data.Bifunctor.Clown":"purescript-bifunctors","Data.Foldable":"purescript-foldable-traversable","Data.Enum":"purescript-enums","Control.Apply":"purescript-prelude","Data.Tuple.Nested":"purescript-tuples","Data.Generic.Rep.Semigroup":"purescript-generics-rep","Control.Monad":"purescript-prelude","Data.Lazy":"purescript-lazy","Data.Monoid":"purescript-prelude","Data.Maybe.First":"purescript-maybe","Control.Bind":"purescript-prelude","Data.Monoid.Additive":"purescript-prelude","Data.Symbol":"purescript-prelude","Data.HeytingAlgebra":"purescript-prelude","Control.Alt":"purescript-control","Type.Data.RowList":"purescript-prelude","Effect.Ref":"purescript-refs","Data.Either.Inject":"purescript-either","Data.List.ZipList":"purescript-lists","Data.Ord.Min":"purescript-orders","Data.Ord.Unsafe":"purescript-prelude","Data.Semigroup":"purescript-prelude","Data.Generic.Rep.Enum":"purescript-generics-rep","Data.Generic.Rep.Bounded":"purescript-generics-rep","Data.Ord.Down":"purescript-orders","Data.Generic.Rep.Show":"purescript-generics-rep","Effect.Unsafe":"purescript-effect","Data.Tuple":"purescript-tuples","Data.Semigroup.Foldable":"purescript-foldable-traversable","Control.Biapply":"purescript-bifunctors","Data.Distributive":"purescript-distributive","Type.Equality":"purescript-type-equality","Control.Alternative":"purescript-control","Data.Semiring":"purescript-prelude","Data.Traversable.Accum":"purescript-foldable-traversable","Data.CommutativeRing":"purescript-prelude","Data.NaturalTransformation":"purescript-prelude","Data.Monoid.Conj":"purescript-prelude","Data.Unfoldable":"purescript-unfoldable","Data.List.Types":"purescript-lists","Data.Functor":"purescript-prelude","Data.Generic.Rep.Ord":"purescript-generics-rep","Data.List.Lazy.Types":"purescript-lists","Control.Category":"purescript-prelude","Control.Monad.Gen.Common":"purescript-gen","Data.Maybe":"purescript-maybe","Control.Comonad":"purescript-control","Data.Function":"purescript-prelude","Data.List":"purescript-lists","Data.Field":"purescript-prelude","Data.List.Lazy":"purescript-lists","Data.Generic.Rep.Eq":"purescript-generics-rep","Data.EuclideanRing":"purescript-prelude","Data.Semigroup.Last":"purescript-prelude","Data.Semigroup.First":"purescript-prelude","Data.Functor.Invariant":"purescript-invariant","Prelude":"purescript-prelude","Effect.Class":"purescript-effect","Partial.Unsafe":"purescript-partial","Data.Bifunctor.Product":"purescript-bifunctors","Control.Extend":"purescript-control","Data.Unfoldable1":"purescript-unfoldable","Control.Lazy":"purescript-control","Data.Eq":"purescript-prelude","Data.Either.Nested":"purescript-either","Data.Newtype":"purescript-newtype","Data.Semigroup.Traversable":"purescript-foldable-traversable","Data.Bifunctor":"purescript-bifunctors","Data.Monoid.Disj":"purescript-prelude","Control.Monad.Gen.Class":"purescript-gen","Control.MonadPlus":"purescript-control","Data.Void":"purescript-prelude","Control.MonadZero":"purescript-control","Data.Ord.Max":"purescript-orders","Data.Bifunctor.Joker":"purescript-bifunctors","Data.FunctorWithIndex":"purescript-foldable-traversable","Data.DivisionRing":"purescript-prelude","Data.Bifunctor.Wrap":"purescript-bifunctors","Data.Maybe.Last":"purescript-maybe","Data.Unit":"purescript-prelude","Data.List.NonEmpty":"purescript-lists","Data.Generic.Rep.Semiring":"purescript-generics-rep","Data.List.Lazy.NonEmpty":"purescript-lists","Data.Ordering":"purescript-prelude","Data.Identity":"purescript-identity","Control.Plus":"purescript-control","Partial":"purescript-partial","Data.Monoid.Multiplicative":"purescript-prelude","Data.Generic.Rep.HeytingAlgebra":"purescript-generics-rep","Data.Generic.Rep.Monoid":"purescript-generics-rep","Control.Semigroupoid":"purescript-prelude","Data.Monoid.Alternate":"purescript-control","Data.Generic.Rep":"purescript-generics-rep","Data.Bifunctor.Join":"purescript-bifunctors","Data.Bifoldable":"purescript-foldable-traversable","Data.Monoid.Endo":"purescript-prelude","Data.List.Partial":"purescript-lists","Data.Either":"purescript-either","Control.Applicative":"purescript-prelude","Data.FoldableWithIndex":"purescript-foldable-traversable","Record.Unsafe":"purescript-prelude","Data.Traversable":"purescript-foldable-traversable"},"compilerVersion":"0.13.3"}