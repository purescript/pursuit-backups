{"uploader":"JordanMartinez","packageMeta":{"repository":{"url":"https://github.com/purescript-contrib/purescript-parsing.git","type":"git"},"ignore":["**/.*","node_modules","bower_components","output"],"devDependencies":{"purescript-effect":"^4.0.0","purescript-node-process":"^9.0.0","purescript-assert":"^6.0.0"},"dependencies":{"purescript-newtype":"^5.0.0","purescript-unicode":"^6.0.0","purescript-control":"^6.0.0","purescript-either":"^6.0.0","purescript-arrays":"^7.0.0","purescript-maybe":"^6.0.0","purescript-unfoldable":"^6.0.0","purescript-foldable-traversable":"^6.0.0","purescript-tailrec":"^6.0.0","purescript-prelude":"^6.0.0","purescript-unsafe-coerce":"^6.0.0","purescript-integers":"^6.0.0","purescript-transformers":"^6.0.0","purescript-numbers":"^9.0.0","purescript-tuples":"^7.0.0","purescript-strings":"^6.0.0","purescript-identity":"^6.0.0","purescript-lists":"^7.0.0","purescript-nullable":"^6.0.0"},"name":"purescript-parsing","license":["BSD-2-Clause"]},"tagTime":"2022-04-28T00:03:31+0000","modules":[{"reExports":[],"name":"Parsing","comments":"Types and operations for monadic parsing.\n\nCombinators are in the `Parsing.Combinators` module.\n\nPrimitive parsers for `String` input streams are in the `Parsing.String`\nmodule.\n","declarations":[{"kind":null,"children":[],"comments":"The `Parser s` monad, where `s` is the type of the input stream.\n\nA synonym for the `ParserT` monad transformer applied\nto the `Identity` monad.\n","title":"Parser","info":{"arguments":[["s",null]],"declType":"typeSynonym","type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Identity"],"Identity"]}]}},"sourceSpan":{"start":[156,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[156,35]}},{"kind":null,"children":[],"comments":"Run a parser on an input stream `s` and produce either an error or the\nresult `a` of the parser.\n","title":"runParser","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"Parser"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Either"],"Either"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParseError"]}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}]},null]},null]}},"sourceSpan":{"start":[160,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[160,64]}},{"kind":{"kind":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Type"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Type"]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Type"]}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Type"]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Type"]}]}]}]},"keyword":"newtype"},"children":[{"comments":null,"title":"ParserT","info":{"arguments":[{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"ForAll","contents":["r",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Function","Uncurried"],"Fn5"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParseState"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]},{"annotation":[],"tag":"TypeVar","contents":"r"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"r"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"m"},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]},{"annotation":[],"tag":"TypeVar","contents":"r"}]}}]}]},{"annotation":[],"tag":"TypeVar","contents":"r"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Function","Uncurried"],"Fn2"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParseState"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]}}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParseError"]}]},{"annotation":[],"tag":"TypeVar","contents":"r"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Function","Uncurried"],"Fn2"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParseState"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"r"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"r"}]},null]}}],"declType":"dataConstructor"},"sourceSpan":{"start":[88,23],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[111,4]}},{"comments":null,"title":"<anonymous>","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Lazy"],"Lazy"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[193,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[200,21]}},{"comments":null,"title":"<anonymous>","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintKindArgs":[],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Semigroup"],"Semigroup"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[202,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[203,22]}},{"comments":null,"title":"<anonymous>","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Monoid"],"Monoid"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintKindArgs":[],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Monoid"],"Monoid"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[205,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[206,23]}},{"comments":null,"title":"<anonymous>","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Functor"],"Functor"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]}]}},"sourceSpan":{"start":[208,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[217,6]}},{"comments":null,"title":"<anonymous>","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Apply"],"Apply"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]}]}},"sourceSpan":{"start":[219,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[232,6]}},{"comments":null,"title":"<anonymous>","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Applicative"],"Applicative"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]}]}},"sourceSpan":{"start":[234,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[238,6]}},{"comments":null,"title":"<anonymous>","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Bind"],"Bind"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]}]}},"sourceSpan":{"start":[240,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[250,6]}},{"comments":null,"title":"<anonymous>","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Monad"],"Monad"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]}]}},"sourceSpan":{"start":[252,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[252,29]}},{"comments":null,"title":"<anonymous>","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Monad","Rec","Class"],"MonadRec"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]}]}},"sourceSpan":{"start":[254,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[276,6]}},{"comments":null,"title":"<anonymous>","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Control","Monad","State","Class"],"MonadState"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"t"},{"annotation":[],"tag":"TypeVar","contents":"m"}],"constraintKindArgs":[],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Monad","State","Class"],"MonadState"]},{"annotation":[],"tag":"TypeVar","contents":"t"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]}]}},"sourceSpan":{"start":[278,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[279,27]}},{"comments":null,"title":"<anonymous>","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Monad","Error","Class"],"MonadThrow"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParseError"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]}]}},"sourceSpan":{"start":[281,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[285,6]}},{"comments":null,"title":"<anonymous>","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Monad","Error","Class"],"MonadError"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParseError"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]}]}},"sourceSpan":{"start":[287,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[297,6]}},{"comments":"The alternative `Alt` instance provides the `alt` combinator `<|>`.\n\nThe expression `p_left <|> p_right` will first try the `p_left` parser and if that fails\n__and consumes no input__ then it will try the `p_right` parser.\n\nWhile we are parsing down the `p_left` branch we may reach a point where\nwe know this is the correct branch, but we cannot parse further. At\nthat point we want to fail the entire parse instead of trying the `p_right`\nbranch.\n\nFor example, consider this `fileParser` which can parse either an HTML\nfile that begins with `<html>` or a shell script file that begins with `#!`.\n\n```\nfileParser =\n  string \"<html>\" *> parseTheRestOfTheHtml\n  <|>\n  string \"#!\" *> parseTheRestOfTheScript\n```\n\nIf we read a file from disk and run this `fileParser` on it and the\n`string \"<html>\"` parser succeeds, then we know that the first branch\nis the correct branch, so we want to commit to the first branch.\nEven if the `parseTheRestOfTheHtml` parser fails\nwe don’t want to try the second branch.\n\nTo control the point at which we commit to the `p_left` branch\nuse the `try` combinator and the `lookAhead` combinator and\nthe `consume` function.\n\nThe `alt` combinator works this way because it gives us good localized\nerror messages while also allowing an efficient implementation. See\n[*Parsec: Direct Style Monadic Parser Combinators For The Real World*](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/parsec-paper-letter.pdf)\nsection __2.3 Backtracking__.\n","title":"<anonymous>","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Alt"],"Alt"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]}]}},"sourceSpan":{"start":[333,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[346,6]}},{"comments":null,"title":"<anonymous>","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Plus"],"Plus"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]}]}},"sourceSpan":{"start":[348,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[349,32]}},{"comments":null,"title":"<anonymous>","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Alternative"],"Alternative"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]}]}},"sourceSpan":{"start":[351,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[351,35]}},{"comments":null,"title":"<anonymous>","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","MonadPlus"],"MonadPlus"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]}]}},"sourceSpan":{"start":[353,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[353,33]}},{"comments":null,"title":"<anonymous>","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Monad","Trans","Class"],"MonadTrans"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]}]}},"sourceSpan":{"start":[355,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[359,6]}}],"comments":"The `Parser s` monad with a monad transformer parameter `m`.\n","title":"ParserT","info":{"declType":"data","dataDeclType":"newtype","typeArguments":[["s",null],["m",null],["a",null]]},"sourceSpan":{"start":[88,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[111,4]}},{"kind":null,"children":[],"comments":"`runParser` with a monad transfomer parameter `m`.\n","title":"runParserT","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Control","Monad","Rec","Class"],"MonadRec"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"m"}],"constraintKindArgs":[],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"m"},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Either"],"Either"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParseError"]}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[121,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[121,88]}},{"kind":null,"children":[],"comments":"Run a parser and produce either an error or the result of the parser\nalong with the internal state of the parser when it finishes.\n","title":"runParserT'","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Control","Monad","Rec","Class"],"MonadRec"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"m"}],"constraintKindArgs":[],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParseState"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"m"},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Either"],"Either"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParseError"]}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParseState"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]}}]}}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[129,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[134,52]}},{"kind":null,"children":[{"comments":null,"title":"ParseError","info":{"arguments":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"Position"]}],"declType":"dataConstructor"},"sourceSpan":{"start":[51,17],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[51,29]}},{"comments":null,"title":"showParseError","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Show"],"Show"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParseError"]}]}},"sourceSpan":{"start":[59,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[61,57]}},{"comments":null,"title":"eqParseError","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Eq"],"Eq"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParseError"]}]}},"sourceSpan":{"start":[63,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[63,46]}},{"comments":null,"title":"ordParseError","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Ord"],"Ord"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParseError"]}]}},"sourceSpan":{"start":[64,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[64,48]}},{"comments":null,"title":"<anonymous>","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Monad","Error","Class"],"MonadThrow"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParseError"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]}]}},"sourceSpan":{"start":[281,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[285,6]}},{"comments":null,"title":"<anonymous>","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Monad","Error","Class"],"MonadError"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParseError"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]}]}},"sourceSpan":{"start":[287,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[297,6]}}],"comments":"A parsing error, consisting of an error message and\nthe position in the input stream at which the error occurred.\n","title":"ParseError","info":{"declType":"data","dataDeclType":"data","typeArguments":[]},"sourceSpan":{"start":[51,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[51,45]}},{"kind":null,"children":[],"comments":null,"title":"parseErrorMessage","info":{"declType":"value","type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParseError"]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]}},"sourceSpan":{"start":[53,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[53,42]}},{"kind":null,"children":[],"comments":null,"title":"parseErrorPosition","info":{"declType":"value","type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParseError"]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"Position"]}]}},"sourceSpan":{"start":[56,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[56,45]}},{"kind":null,"children":[{"comments":null,"title":"Position","info":{"arguments":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Record"]},{"annotation":[],"tag":"RCons","contents":["index",{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]},{"annotation":[],"tag":"RCons","contents":["line",{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]},{"annotation":[],"tag":"RCons","contents":["column",{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]},{"annotation":[],"tag":"REmpty"}]}]}]}]}],"declType":"dataConstructor"},"sourceSpan":{"start":[412,18],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[416,4]}},{"comments":null,"title":"<anonymous>","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Generic","Rep"],"Generic"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"Position"]}]},{"annotation":[],"tag":"TypeWildcard","contents":null}]}},"sourceSpan":{"start":[418,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[418,35]}},{"comments":null,"title":"<anonymous>","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Show"],"Show"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"Position"]}]}},"sourceSpan":{"start":[419,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[420,25]}},{"comments":null,"title":"<anonymous>","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Eq"],"Eq"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"Position"]}]}},"sourceSpan":{"start":[422,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[423,52]}},{"comments":null,"title":"<anonymous>","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Ord"],"Ord"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"Position"]}]}},"sourceSpan":{"start":[425,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[426,62]}}],"comments":"`Position` represents the position of the parser in the input stream.\n\n- `index` is the position offset since the start of the input. Starts\n  at *0*.\n- `line` is the current line in the input. Starts at *1*.\n- `column` is the column of the next character in the current line that\n  will be parsed. Starts at *1*.\n","title":"Position","info":{"declType":"data","dataDeclType":"newtype","typeArguments":[]},"sourceSpan":{"start":[412,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[416,4]}},{"kind":null,"children":[],"comments":"The `Position` before any input has been parsed.\n\n`{ index: 0, line: 1, column: 1 }`\n","title":"initialPos","info":{"declType":"value","type":{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"Position"]}},"sourceSpan":{"start":[431,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[431,23]}},{"kind":null,"children":[],"comments":"Set the consumed flag.\n\nSetting the consumed flag means that we're committed to this parsing branch\nof an alternative (`<|>`), so that if this branch fails then we want to\nfail the entire parse instead of trying the other alternative.\n","title":"consume","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]},null]},null]}},"sourceSpan":{"start":[384,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[384,40]}},{"kind":null,"children":[],"comments":"Returns the current position in the stream.\n","title":"position","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"Position"]}]},null]},null]}},"sourceSpan":{"start":[388,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[388,45]}},{"kind":null,"children":[],"comments":"Fail with a message.\n","title":"fail","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},null]},null]},null]}},"sourceSpan":{"start":[392,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[392,46]}},{"kind":null,"children":[],"comments":"Fail with a message and a position.\n","title":"failWithPosition","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"Position"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[396,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[396,70]}},{"kind":null,"children":[],"comments":"Contextualize parsing failures inside a region. If a parsing failure\noccurs, then the `ParseError` will be transformed by each containing\n`region` as the parser backs out the call stack.\n","title":"region","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParseError"]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParseError"]}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[402,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[402,85]}},{"kind":null,"children":[{"comments":null,"title":"ParseState","info":{"arguments":[{"annotation":[],"tag":"TypeVar","contents":"s"},{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"Position"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}],"declType":"dataConstructor"},"sourceSpan":{"start":[73,19],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[73,31]}}],"comments":"The internal state of the `ParserT s m` monad.\n\nContains the remaining input and current position and the consumed flag.\n\nThe consumed flag is used to implement the rule for `alt` that\n- If the left parser fails *without consuming any input*, then backtrack and try the right parser.\n- If the left parser fails and consumes input, then fail immediately.\n","title":"ParseState","info":{"declType":"data","dataDeclType":"data","typeArguments":[["s",null]]},"sourceSpan":{"start":[73,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[73,50]}},{"kind":null,"children":[],"comments":"Query and modify the `ParserT` internal state.\n\nLike the `state` member of `MonadState`.\n","title":"stateParserT","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParseState"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParseState"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]}}]}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},null]},null]},null]}},"sourceSpan":{"start":[364,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[364,88]}},{"kind":null,"children":[],"comments":"Query the `ParserT` internal state.\n\nLike the `get` member of `MonadState`.\n","title":"getParserT","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParseState"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]}}]},null]},null]}},"sourceSpan":{"start":[374,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[374,53]}},{"kind":null,"children":[],"comments":null,"title":"hoistParserT","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["n",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"BinaryNoParensType","contents":[{"annotation":[],"tag":"TypeOp","contents":[["Data","NaturalTransformation"],"~>"]},{"annotation":[],"tag":"TypeVar","contents":"m"},{"annotation":[],"tag":"TypeVar","contents":"n"}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"n"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}]},null]},null]},null]},null]}},"sourceSpan":{"start":[163,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[163,75]}},{"kind":null,"children":[],"comments":"Change the underlying monad action `m` and result data type `a` in\na `ParserT s m` monad action.\n","title":"mapParserT","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["n",{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Control","Monad","Rec","Class"],"MonadRec"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"m"}],"constraintKindArgs":[],"constraintData":null},{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Functor"],"Functor"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"n"}],"constraintKindArgs":[],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"m"},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Either"],"Either"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParseError"]}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParseState"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]}}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"n"},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Either"],"Either"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParseError"]}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParseState"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]}}]}}]}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"n"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}]}]}]},null]},null]},null]},null]},null]}},"sourceSpan":{"start":[171,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing.purs","end":[179,19]}}]},{"reExports":[{"moduleName":{"package":"purescript-control","item":["Control","Plus"]},"declarations":[{"kind":null,"children":[],"comments":null,"title":"alt","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["f",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[null,"Alt"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintKindArgs":[],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}]}]},null]},null]}},"sourceSpan":{"start":[37,3],"name":"bower_components/purescript-control/src/Control/Alt.purs","end":[37,37]}},{"kind":null,"children":[],"comments":null,"title":"empty","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["f",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[null,"Plus"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintKindArgs":[],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},null]},null]}},"sourceSpan":{"start":[24,3],"name":"bower_components/purescript-control/src/Control/Plus.purs","end":[24,25]}},{"kind":null,"children":[],"comments":null,"title":"(<|>)","info":{"declType":"alias","alias":[["Control","Alt"],{"Right":{"Left":{"Ident":"alt"}}}],"fixity":{"associativity":"infixr","precedence":3}},"sourceSpan":{"start":[39,1],"name":"bower_components/purescript-control/src/Control/Alt.purs","end":[39,20]}}]},{"moduleName":{"package":"purescript-lists","item":["Data","List","Lazy"]},"declarations":[{"kind":null,"children":[],"comments":"Perform a monadic action `n` times collecting all of the results.\n","title":"replicateM","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Control","Monad"],"Monad"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"m"}],"constraintKindArgs":[],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"m"},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"m"},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Lazy","Types"],"List"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]}]}]}]},null]},null]}},"sourceSpan":{"start":[164,1],"name":"bower_components/purescript-lists/src/Data/List/Lazy.purs","end":[164,62]}}]},{"moduleName":{"package":"purescript-unfoldable","item":["Data","Unfoldable"]},"declarations":[{"kind":null,"children":[],"comments":"Perform an Applicative action `n` times, and accumulate all the results.\n\n``` purescript\n> replicateA 5 (randomInt 1 10) :: Effect (Array Int)\n[1,3,2,7,5]\n```\n","title":"replicateA","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["f",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Control","Applicative"],"Applicative"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"m"}],"constraintKindArgs":[],"constraintData":null},{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Unfoldable"],"Unfoldable"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintKindArgs":[],"constraintData":null},{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Traversable"],"Traversable"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintKindArgs":[],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"m"},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"m"},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]}]}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[77,1],"name":"bower_components/purescript-unfoldable/src/Data/Unfoldable.purs","end":[84,13]}}]},{"moduleName":{"package":"purescript-unfoldable","item":["Data","Unfoldable1"]},"declarations":[{"kind":null,"children":[],"comments":"Perform an `Apply` action `n` times (at least once, so values `n` less\nthan 1 will be treated as 1), and accumulate the results.\n\n``` purescript\n> replicate1A 2 (randomInt 1 10) :: Effect (NEL.NonEmptyList Int)\n(NonEmptyList (NonEmpty 8 (2 : Nil)))\n> replicate1A 0 (randomInt 1 10) :: Effect (NEL.NonEmptyList Int)\n(NonEmptyList (NonEmpty 4 Nil))\n```\n","title":"replicate1A","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["f",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Control","Apply"],"Apply"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"m"}],"constraintKindArgs":[],"constraintData":null},{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Unfoldable1"],"Unfoldable1"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintKindArgs":[],"constraintData":null},{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Semigroup","Traversable"],"Traversable1"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintKindArgs":[],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"m"},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"m"},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]}]}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[82,1],"name":"bower_components/purescript-unfoldable/src/Data/Unfoldable1.purs","end":[89,13]}}]}],"name":"Parsing.Combinators","comments":"A “parser combinator” is a function which takes some\nparsers as arguments and returns a new parser.\n\n## Combinators in other packages\n\nMany variations of well-known monadic and applicative combinators used for parsing are\ndefined in other PureScript packages. We list some of them here.\n\nIf you use a combinator from some other package for parsing, keep in mind\nthis surprising truth about the __parsing__ package:\nAll other combinators used with this package will be stack-safe,\nbut usually the combinators with a `MonadRec` constraint will run faster.\nSo you should prefer `MonadRec` versions of combinators, but for reasons\nof speed, not stack-safety.\n\n### Data.Array\n\nExpect better parsing speed from the `List`-based combinators in this\nmodule than from `Array`-based combinators.\n\n* [Data.Array.many](https://pursuit.purescript.org/packages/purescript-arrays/docs/Data.Array#v:many)\n* [Data.Array.some](https://pursuit.purescript.org/packages/purescript-arrays/docs/Data.Array#v:some)\n* [Data.Array.NonEmpty.some](https://pursuit.purescript.org/packages/purescript-arrays/docs/Data.Array.NonEmpty#v:some)\n\n### Data.List\n\nThe `many` and `many1` combinators in this package\nare redeclarations of\nthe `manyRec` and `someRec` combinators in __Data.List__.\n\n### Data.List.Lazy\n\n* [Data.List.Lazy.many](https://pursuit.purescript.org/packages/purescript-lists/docs/Data.List.Lazy#v:many)\n* [Data.List.Lazy.some](https://pursuit.purescript.org/packages/purescript-lists/docs/Data.List.Lazy#v:some)\n\n## Combinators in this package\n\nthe __replicateA__ and __replicateM__ combinators are re-exported from\nthis module. `replicateA n p` or `replicateM n p`\nwill repeat parser `p` exactly `n` times. The `replicateA` combinator can\nproduce either an `Array` or a `List`.\n","declarations":[{"kind":null,"children":[],"comments":"If the parser fails then backtrack the input stream to the unconsumed state.\n\nOne use for this combinator is to ensure that the right parser of an\nalternative will always be tried when the left parser fails.\n```\n>>> runParser \"ac\" ((char 'a' *> char 'b') <|> (char 'a' *> char 'c'))\nLeft (ParseError \"Expected 'b'\" (Position { line: 1, column: 2 }))\n```\n\n```\n>>> runParser \"ac\" (try (char 'a' *> char 'b') <|> (char 'a' *> char 'c'))\nRight 'c'\n```\n","title":"try","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},null]},null]},null]}},"sourceSpan":{"start":[165,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Combinators.purs","end":[165,52]}},{"kind":null,"children":[],"comments":"If the parser fails then backtrack the input stream to the unconsumed state.\n\nLike `try`, but will reposition the error to the `try` point.\n\n```\n>>> runParser \"ac\" (try (char 'a' *> char 'b'))\nLeft (ParseError \"Expected 'b'\" (Position { index: 1, line: 1, column: 2 }))\n```\n\n```\n>>> runParser \"ac\" (tryRethrow (char 'a' *> char 'b'))\nLeft (ParseError \"Expected 'b'\" (Position { index: 0, line: 1, column: 1 }))\n```\n","title":"tryRethrow","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},null]},null]},null]}},"sourceSpan":{"start":[188,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Combinators.purs","end":[188,59]}},{"kind":null,"children":[],"comments":"Parse a phrase, without modifying the consumed state or stream position.\n","title":"lookAhead","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},null]},null]},null]}},"sourceSpan":{"start":[199,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Combinators.purs","end":[199,58]}},{"kind":null,"children":[],"comments":"Parse one of a set of alternatives.\n","title":"choice","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["f",{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Foldable"],"Foldable"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintKindArgs":[],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}]},null]},null]},null]},null]}},"sourceSpan":{"start":[354,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Combinators.purs","end":[354,75]}},{"kind":null,"children":[],"comments":"Wrap a parser with opening and closing markers.\n\nFor example:\n\n```purescript\nparens = between (string \"(\") (string \")\")\n```\n","title":"between","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["open",{"annotation":[],"tag":"ForAll","contents":["close",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"open"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"close"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}]}]},null]},null]},null]},null]},null]}},"sourceSpan":{"start":[135,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Combinators.purs","end":[135,108]}},{"kind":null,"children":[],"comments":"Fail if the parser succeeds.\n\nWill never consume input.\n","title":"notFollowedBy","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]}]},null]},null]},null]}},"sourceSpan":{"start":[374,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Combinators.purs","end":[374,65]}},{"kind":null,"children":[],"comments":"Provide a default result in the case where a parser fails without consuming input.\n","title":"option","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[139,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Combinators.purs","end":[139,60]}},{"kind":null,"children":[],"comments":"pure `Nothing` in the case where a parser fails without consuming input.\n","title":"optionMaybe","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]}]},null]},null]},null]}},"sourceSpan":{"start":[149,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Combinators.purs","end":[149,68]}},{"kind":null,"children":[],"comments":"Optionally parse something, failing quietly.\n\nTo optionally parse `p` and never fail: `optional (try p)`.\n","title":"optional","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]}]},null]},null]},null]}},"sourceSpan":{"start":[145,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Combinators.purs","end":[145,60]}},{"kind":null,"children":[],"comments":"Match the parser `p` as many times as possible.\n\nIf `p` never consumes input when it\nfails then `many p` will always succeed,\nbut may return an empty list.\n","title":"many","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"List"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]}]},null]},null]},null]}},"sourceSpan":{"start":[212,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Combinators.purs","end":[212,60]}},{"kind":null,"children":[],"comments":"Match one or more times.\n","title":"many1","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"NonEmptyList"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]}]},null]},null]},null]}},"sourceSpan":{"start":[216,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Combinators.purs","end":[216,69]}},{"kind":null,"children":[],"comments":"Parse many phrases until the terminator phrase matches.\n","title":"manyTill","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["e",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"e"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"List"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]}]}]},null]},null]},null]},null]}},"sourceSpan":{"start":[378,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Combinators.purs","end":[378,83]}},{"kind":null,"children":[],"comments":"Parse many phrases until the terminator phrase matches.\nReturns the list of phrases and the terminator phrase.\n\n#### Non-greedy repetition\n\nUse the __manyTill_ __ combinator\nto do non-greedy repetition of a pattern `p`, like we would in Regex\nby writing `p*?`.\nTo repeat pattern `p` non-greedily, write\n`manyTill_ p q` where `q` is the entire rest of the parser.\n\nFor example, this parse fails because `many` repeats the pattern `letter`\ngreedily.\n\n```\nrunParser \"aab\" do\n  a <- many letter\n  b <- char 'b'\n  pure (Tuple a b)\n```\n```\n(ParseError \"Expected 'b'\" (Position { line: 1, column: 4 }))\n```\n\nTo repeat pattern `letter` non-greedily, use `manyTill_`.\n\n```\nrunParser \"aab\" do\n  Tuple a b <- manyTill_ letter do\n    char 'b'\n  pure (Tuple a b)\n```\n```\n(Tuple ('a' : 'a' : Nil) 'b')\n```\n","title":"manyTill_","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["e",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"e"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"List"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"e"}]}}]}]}]},null]},null]},null]},null]}},"sourceSpan":{"start":[433,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Combinators.purs","end":[433,94]}},{"kind":null,"children":[],"comments":"Parse at least one phrase until the terminator phrase matches.\n","title":"many1Till","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["e",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"e"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"NonEmptyList"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]}]}]},null]},null]},null]},null]}},"sourceSpan":{"start":[387,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Combinators.purs","end":[387,92]}},{"kind":null,"children":[],"comments":"Parse many phrases until the terminator phrase matches, requiring at least one match.\nReturns the list of phrases and the terminator phrase.\n","title":"many1Till_","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["e",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"e"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"NonEmptyList"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"e"}]}}]}]}]},null]},null]},null]},null]}},"sourceSpan":{"start":[392,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Combinators.purs","end":[392,103]}},{"kind":null,"children":[],"comments":"Parse the phrase as many times as possible, at least *N* times, but no\nmore than *M* times.\nIf the phrase can’t parse as least *N* times then the whole\nparser fails. If the phrase parses successfully *M* times then stop.\nThe current phrase index, starting at *0*, is passed to the phrase.\n\nReturns the list of parse results and the number of results.\n\n`manyIndex n n (\\_ -> p)` is equivalent to `replicateA n p`.\n","title":"manyIndex","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"List"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]}}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[455,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Combinators.purs","end":[455,100]}},{"kind":null,"children":[],"comments":"Skip many instances of a phrase.\n","title":"skipMany","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]}]},null]},null]},null]}},"sourceSpan":{"start":[362,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Combinators.purs","end":[362,60]}},{"kind":null,"children":[],"comments":"Skip at least one instance of a phrase.\n","title":"skipMany1","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]}]},null]},null]},null]}},"sourceSpan":{"start":[366,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Combinators.purs","end":[366,61]}},{"kind":null,"children":[],"comments":"Parse phrases delimited by a separator.\n\nFor example:\n\n```purescript\ndigit `sepBy` string \",\"\n```\n","title":"sepBy","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["sep",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"sep"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"List"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]}]}]},null]},null]},null]},null]}},"sourceSpan":{"start":[226,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Combinators.purs","end":[226,84]}},{"kind":null,"children":[],"comments":"Parse phrases delimited by a separator, requiring at least one match.\n","title":"sepBy1","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["sep",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"sep"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"NonEmptyList"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]}]}]},null]},null]},null]},null]}},"sourceSpan":{"start":[230,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Combinators.purs","end":[230,93]}},{"kind":null,"children":[],"comments":"Parse phrases delimited and optionally terminated by a separator.\n","title":"sepEndBy","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["sep",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"sep"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"List"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]}]}]},null]},null]},null]},null]}},"sourceSpan":{"start":[237,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Combinators.purs","end":[237,87]}},{"kind":null,"children":[],"comments":"Parse phrases delimited and optionally terminated by a separator, requiring at least one match.\n","title":"sepEndBy1","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["sep",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"sep"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"NonEmptyList"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]}]}]},null]},null]},null]},null]}},"sourceSpan":{"start":[241,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Combinators.purs","end":[241,96]}},{"kind":null,"children":[],"comments":"Parse phrases delimited and terminated by a separator.\n","title":"endBy","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["sep",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"sep"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"List"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]}]}]},null]},null]},null]},null]}},"sourceSpan":{"start":[262,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Combinators.purs","end":[262,84]}},{"kind":null,"children":[],"comments":"Parse phrases delimited and terminated by a separator, requiring at least one match.\n","title":"endBy1","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["sep",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"sep"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"NonEmptyList"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]}]}]},null]},null]},null]},null]}},"sourceSpan":{"start":[258,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Combinators.purs","end":[258,93]}},{"kind":null,"children":[],"comments":"`chainl p f` parses one or more occurrences of `p`, separated by operator `f`.\n\nReturns a value\nobtained by a left-associative application of the functions returned by\n`f` to the values returned by `p`. This combinator can be used to\neliminate left-recursion in expression grammars.\n\nFor example:\n\n```purescript\nchainl digit (string \"+\" $> add) 0\n```\n","title":"chainl","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[277,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Combinators.purs","end":[277,89]}},{"kind":null,"children":[],"comments":"`chainl` requiring at least one match.\n","title":"chainl1","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[281,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Combinators.purs","end":[281,85]}},{"kind":null,"children":[],"comments":"`chainr p f` parses one or more occurrences of `p`, separated by operator `f`.\n\nReturns a value\nobtained by a right-associative application of the functions returned by\n`f` to the values returned by `p`. This combinator can be used to\neliminate right-recursion in expression grammars.\n\nFor example:\n\n```purescript\nchainr digit (string \"+\" $> add) 0\n```\n","title":"chainr","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[307,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Combinators.purs","end":[307,89]}},{"kind":null,"children":[],"comments":"`chainr` requiring at least one match.\n","title":"chainr1","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[311,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Combinators.purs","end":[311,85]}},{"kind":null,"children":[],"comments":"If the parser succeeds without advancing the input stream position,\nthen force the parser to fail.\n\nThis combinator can be used to prevent infinite parser repetition.\n\nDoes not depend on or effect the `consumed` flag which indicates whether\nwe are committed to this parsing branch.\n","title":"advance","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},null]},null]},null]}},"sourceSpan":{"start":[484,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Combinators.purs","end":[484,56]}},{"kind":null,"children":[],"comments":"Provide an error message in the case of failure.\n","title":"withErrorMessage","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[104,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Combinators.purs","end":[104,75]}},{"kind":null,"children":[],"comments":null,"title":"(<?>)","info":{"declType":"alias","alias":[["Parsing","Combinators"],{"Right":{"Left":{"Ident":"withErrorMessage"}}}],"fixity":{"associativity":"infixl","precedence":4}},"sourceSpan":{"start":[107,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Combinators.purs","end":[107,33]}},{"kind":null,"children":[],"comments":"Provide an error message in the case of failure, but lazily. This is handy\nin cases where constructing the error message is expensive, so it's\npreferable to defer it until an error actually happens.\n\n```purescript\nparseBang :: Parser Char\nparseBang = char '!' <~?> \\_ -> \"Expected a bang\"\n```\n","title":"withLazyErrorMessage","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[117,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Combinators.purs","end":[117,89]}},{"kind":null,"children":[],"comments":null,"title":"(<~?>)","info":{"declType":"alias","alias":[["Parsing","Combinators"],{"Right":{"Left":{"Ident":"withLazyErrorMessage"}}}],"fixity":{"associativity":"infixl","precedence":4}},"sourceSpan":{"start":[120,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Combinators.purs","end":[120,38]}},{"kind":null,"children":[],"comments":"Flipped `(<?>)`.\n","title":"asErrorMessage","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[123,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Combinators.purs","end":[123,73]}},{"kind":null,"children":[],"comments":null,"title":"(<??>)","info":{"declType":"alias","alias":[["Parsing","Combinators"],{"Right":{"Left":{"Ident":"asErrorMessage"}}}],"fixity":{"associativity":"infixr","precedence":3}},"sourceSpan":{"start":[126,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Combinators.purs","end":[126,32]}}]},{"reExports":[],"name":"Parsing.Expr","comments":"This module is a port of the Haskell\n[__Text.Parsec.Expr__](https://hackage.haskell.org/package/parsec/docs/Text-Parsec-Expr.html)\nmodule.\n","declarations":[{"kind":null,"children":[{"comments":null,"title":"AssocNone","info":{"arguments":[],"declType":"dataConstructor"},"sourceSpan":{"start":[20,12],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Expr.purs","end":[20,23]}},{"comments":null,"title":"AssocLeft","info":{"arguments":[],"declType":"dataConstructor"},"sourceSpan":{"start":[20,24],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Expr.purs","end":[20,35]}},{"comments":null,"title":"AssocRight","info":{"arguments":[],"declType":"dataConstructor"},"sourceSpan":{"start":[20,36],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Expr.purs","end":[20,48]}}],"comments":null,"title":"Assoc","info":{"declType":"data","dataDeclType":"data","typeArguments":[]},"sourceSpan":{"start":[20,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Expr.purs","end":[20,48]}},{"kind":{"kind":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Type"]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Type"]}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Type"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Type"]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Type"]}]}]}]},"keyword":"data"},"children":[{"comments":null,"title":"Infix","info":{"arguments":[{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}}]}},{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Expr"],"Assoc"]}],"declType":"dataConstructor"},"sourceSpan":{"start":[23,3],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Expr.purs","end":[23,10]}},{"comments":null,"title":"Prefix","info":{"arguments":[{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]}}],"declType":"dataConstructor"},"sourceSpan":{"start":[24,3],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Expr.purs","end":[24,11]}},{"comments":null,"title":"Postfix","info":{"arguments":[{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]}}],"declType":"dataConstructor"},"sourceSpan":{"start":[25,3],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Expr.purs","end":[25,12]}}],"comments":null,"title":"Operator","info":{"declType":"data","dataDeclType":"data","typeArguments":[["m",null],["s",null],["a",null]]},"sourceSpan":{"start":[22,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Expr.purs","end":[25,35]}},{"kind":{"kind":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Type"]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Type"]}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Type"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Type"]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Type"]}]}]}]},"keyword":"type"},"children":[],"comments":null,"title":"OperatorTable","info":{"arguments":[["m",null],["s",null],["a",null]],"declType":"typeSynonym","type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Array"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Array"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Expr"],"Operator"]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]}}]}},"sourceSpan":{"start":[27,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Expr.purs","end":[27,58]}},{"kind":null,"children":[],"comments":"Build a parser from an `OperatorTable`.\n\nFor example:\n\n```purescript\nbuildExprParser [ [ Infix (string \"/\" $> div) AssocRight ]\n                , [ Infix (string \"*\" $> mul) AssocRight ]\n                , [ Infix (string \"-\" $> sub) AssocRight ]\n                , [ Infix (string \"+\" $> add) AssocRight ]\n                ] digit\n```\n","title":"buildExprParser","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Expr"],"OperatorTable"]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[48,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Expr.purs","end":[48,87]}}]},{"reExports":[],"name":"Parsing.Indent","comments":"This module is a port of the Haskell\n[__Text.Parsec.Indent__](https://hackage.haskell.org/package/indents-0.3.3/docs/Text-Parsec-Indent.html)\nmodule from 2016-05-07.\n\nA module to construct indentation aware parsers. Many programming\nlanguage have indentation based syntax rules e.g. python and Haskell.\nThis module exports combinators to create such parsers.\n\nThe input source can be thought of as a list of tokens. Abstractly\neach token occurs at a line and a column and has a width. The column\nnumber of a token measures is indentation. If t1 and t2 are two tokens\nthen we say that indentation of t1 is more than t2 if the column\nnumber of occurrence of t1 is greater than that of t2.\n\nCurrently this module supports two kind of indentation based syntactic\nstructures which we now describe:\n\n- **Block**\n\n  A block of indentation /c/ is a sequence of tokens with\n  indentation at least /c/.  Examples for a block is a where clause of\n  Haskell with no explicit braces.\n\n- **Line fold**\n\n  A line fold starting at line /l/ and indentation /c/ is a\n  sequence of tokens that start at line /l/ and possibly continue to\n  subsequent lines as long as the indentation is greater than /c/. Such\n  a sequence of lines need to be /folded/ to a single line. An example\n  is MIME headers. Line folding based binding separation is used in\n  Haskell as well.\n","declarations":[{"kind":null,"children":[],"comments":"Indentation sensitive parser type. Usually @ m @ will\nbe @ Identity @ as with any @ ParserT @\n","title":"IndentParser","info":{"arguments":[["s",null],["a",null]],"declType":"typeSynonym","type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Monad","State"],"State"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"Position"]}]}}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}},"sourceSpan":{"start":[76,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Indent.purs","end":[76,53]}},{"kind":null,"children":[],"comments":"Run the result of an indentation sensitive parse\n","title":"runIndent","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Monad","State"],"State"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"Position"]}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},null]}},"sourceSpan":{"start":[163,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Indent.purs","end":[163,45]}},{"kind":null,"children":[],"comments":"`withBlock f a p` parses `a`\nfollowed by an indented block of `p`\ncombining them with `f`.\n","title":"withBlock","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["c",{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"List"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Indent"],"IndentParser"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Indent"],"IndentParser"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Indent"],"IndentParser"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"c"}]}]}]}]},null]},null]},null]},null]}},"sourceSpan":{"start":[97,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Indent.purs","end":[97,108]}},{"kind":null,"children":[],"comments":"Like 'withBlock', but throws away initial parse result\n","title":"withBlock'","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Indent"],"IndentParser"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Indent"],"IndentParser"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Indent"],"IndentParser"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"List"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[106,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Indent.purs","end":[106,92]}},{"kind":null,"children":[],"comments":"Parses a block of lines at the same indentation level , empty Blocks allowed\n","title":"block","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Indent"],"IndentParser"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Indent"],"IndentParser"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"List"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]}]},null]},null]}},"sourceSpan":{"start":[142,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Indent.purs","end":[142,65]}},{"kind":null,"children":[],"comments":"Parses a block of lines at the same indentation level\n","title":"block1","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Indent"],"IndentParser"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Indent"],"IndentParser"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"List"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]}]},null]},null]}},"sourceSpan":{"start":[136,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Indent.purs","end":[136,66]}},{"kind":null,"children":[],"comments":"Parses only when indented past the level of the reference\n","title":"indented","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Indent"],"IndentParser"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]},null]}},"sourceSpan":{"start":[110,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Indent.purs","end":[110,42]}},{"kind":null,"children":[],"comments":"Same as `indented`, but does not change internal state\n","title":"indented'","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Indent"],"IndentParser"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]},null]}},"sourceSpan":{"start":[118,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Indent.purs","end":[118,43]}},{"kind":null,"children":[],"comments":"Parses only on the same line as the reference\n","title":"sameLine","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Indent"],"IndentParser"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]},null]}},"sourceSpan":{"start":[129,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Indent.purs","end":[129,42]}},{"kind":null,"children":[],"comments":"Parses only when indented past the level of the reference or on the same line\n","title":"sameOrIndented","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Indent"],"IndentParser"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]},null]}},"sourceSpan":{"start":[125,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Indent.purs","end":[125,48]}},{"kind":null,"children":[],"comments":"Ensures the current indentation level matches that of the reference\n","title":"checkIndent","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Indent"],"IndentParser"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]},null]}},"sourceSpan":{"start":[156,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Indent.purs","end":[156,45]}},{"kind":null,"children":[],"comments":"Parses using the current location for indentation reference\n","title":"withPos","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Indent"],"IndentParser"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Indent"],"IndentParser"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},null]},null]}},"sourceSpan":{"start":[148,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Indent.purs","end":[148,60]}},{"kind":null,"children":[],"comments":"`<+/>` is to indentation sensitive parsers what `ap` is to monads\n","title":"indentAp","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Indent"],"IndentParser"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Indent"],"IndentParser"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Indent"],"IndentParser"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[167,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Indent.purs","end":[167,90]}},{"kind":null,"children":[],"comments":null,"title":"(<+/>)","info":{"declType":"alias","alias":[["Parsing","Indent"],{"Right":{"Left":{"Ident":"indentAp"}}}],"fixity":{"associativity":"infixl","precedence":9}},"sourceSpan":{"start":[170,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Indent.purs","end":[170,26]}},{"kind":null,"children":[],"comments":"Like `<+/>` but doesn't apply the function to the parsed value\n","title":"indentNoAp","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Indent"],"IndentParser"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Indent"],"IndentParser"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Indent"],"IndentParser"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[173,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Indent.purs","end":[173,85]}},{"kind":null,"children":[],"comments":null,"title":"(<-/>)","info":{"declType":"alias","alias":[["Parsing","Indent"],{"Right":{"Left":{"Ident":"indentNoAp"}}}],"fixity":{"associativity":"infixl","precedence":10}},"sourceSpan":{"start":[176,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Indent.purs","end":[176,29]}},{"kind":null,"children":[],"comments":"Like `<+/>` but applies the second parser many times\n","title":"indentMany","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Indent"],"IndentParser"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"List"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Indent"],"IndentParser"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Indent"],"IndentParser"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[179,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Indent.purs","end":[179,97]}},{"kind":null,"children":[],"comments":null,"title":"(<*/>)","info":{"declType":"alias","alias":[["Parsing","Indent"],{"Right":{"Left":{"Ident":"indentMany"}}}],"fixity":{"associativity":"infixl","precedence":11}},"sourceSpan":{"start":[182,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Indent.purs","end":[182,29]}},{"kind":null,"children":[],"comments":"Like `<+/>` but applies the second parser optionally using the `Optional` datatype\n","title":"indentOp","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Indent"],"IndentParser"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Indent"],"Optional"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Indent"],"IndentParser"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[188,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Indent.purs","end":[188,86]}},{"kind":null,"children":[],"comments":null,"title":"(<?/>)","info":{"declType":"alias","alias":[["Parsing","Indent"],{"Right":{"Left":{"Ident":"indentOp"}}}],"fixity":{"associativity":"infixl","precedence":12}},"sourceSpan":{"start":[191,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Indent.purs","end":[191,27]}},{"kind":null,"children":[],"comments":"Parses with surrounding brackets\n","title":"indentBrackets","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Indent"],"IndentParser"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Indent"],"IndentParser"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},null]}},"sourceSpan":{"start":[194,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Indent.purs","end":[194,75]}},{"kind":null,"children":[],"comments":"Parses with surrounding angle brackets\n","title":"indentAngles","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Indent"],"IndentParser"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Indent"],"IndentParser"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},null]}},"sourceSpan":{"start":[198,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Indent.purs","end":[198,73]}},{"kind":null,"children":[],"comments":"Parses with surrounding braces\n","title":"indentBraces","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Indent"],"IndentParser"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Indent"],"IndentParser"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},null]}},"sourceSpan":{"start":[202,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Indent.purs","end":[202,73]}},{"kind":null,"children":[],"comments":"Parses with surrounding parentheses\n","title":"indentParens","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Indent"],"IndentParser"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Indent"],"IndentParser"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},null]}},"sourceSpan":{"start":[206,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Indent.purs","end":[206,73]}},{"kind":null,"children":[{"comments":null,"title":"Opt","info":{"arguments":[{"annotation":[],"tag":"TypeVar","contents":"a"},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Indent"],"IndentParser"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}],"declType":"dataConstructor"},"sourceSpan":{"start":[185,19],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Indent.purs","end":[185,24]}}],"comments":"Data type used to optional parsing\n","title":"Optional","info":{"declType":"data","dataDeclType":"data","typeArguments":[["s",null],["a",null]]},"sourceSpan":{"start":[185,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Indent.purs","end":[185,45]}}]},{"reExports":[],"name":"Parsing.Language","comments":"This module is a port of the Haskell\n[__Text.Parsec.Language__](https://hackage.haskell.org/package/parsec/docs/Text-Parsec-Language.html)\nmodule.\n","declarations":[{"kind":null,"children":[],"comments":"The language definition for the Haskell language.\n","title":"haskellDef","info":{"declType":"value","type":{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Token"],"LanguageDef"]}},"sourceSpan":{"start":[96,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Language.purs","end":[96,26]}},{"kind":null,"children":[],"comments":"A lexer for the haskell language.\n","title":"haskell","info":{"declType":"value","type":{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Token"],"TokenParser"]}},"sourceSpan":{"start":[92,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Language.purs","end":[92,23]}},{"kind":null,"children":[],"comments":"This is the most minimal token definition. It is recommended to use\nthis definition as the basis for other definitions. `emptyDef` has\nno reserved names or operators, is case sensitive and doesn't accept\ncomments, identifiers or operators.\n","title":"emptyDef","info":{"declType":"value","type":{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Token"],"LanguageDef"]}},"sourceSpan":{"start":[69,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Language.purs","end":[69,24]}},{"kind":null,"children":[],"comments":"This is a minimal token definition for Haskell style languages. It\ndefines the style of comments, valid identifiers and case\nsensitivity. It does not define any reserved words or operators.\n","title":"haskellStyle","info":{"declType":"value","type":{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Token"],"LanguageDef"]}},"sourceSpan":{"start":[27,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Language.purs","end":[27,28]}},{"kind":null,"children":[],"comments":"This is a minimal token definition for Java style languages. It\ndefines the style of comments, valid identifiers and case\nsensitivity. It does not define any reserved words or operators.\n","title":"javaStyle","info":{"declType":"value","type":{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Token"],"LanguageDef"]}},"sourceSpan":{"start":[48,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Language.purs","end":[48,25]}}]},{"reExports":[],"name":"Parsing.String","comments":"Primitive parsers for working with an input stream of type `String`.\n\nAll of these primitive parsers will consume their input when they succeed.\n\nAll of these primitive parsers will consume no input when they\nfail.\n\nThe behavior of these primitive parsers is based on the behavior of the\n`Data.String` module in the __strings__ package.\nIn most JavaScript runtime environments, the `String`\nis little-endian [UTF-16](https://en.wikipedia.org/wiki/UTF-16).\n\nThe primitive parsers which return `Char` will only succeed when the character\nbeing parsed is a code point in the\n[Basic Multilingual Plane](https://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane)\n(the “BMP”). These parsers can be convenient because of the good support\nthat PureScript has for writing `Char` literals like `'あ'`, `'β'`, `'C'`.\n\nThe other primitive parsers, which return `CodePoint` and `String` types,\ncan parse the full Unicode character set. All of the primitive parsers\nin this module can be used together.\n\n### Position\n\nIn a `String` parser, the `Position {index}` counts the number of\nunicode `CodePoint`s since the beginning of the input string.\n\nEach tab character (`0x09`) encountered in a `String` parser will advance\nthe `Position {column}` by 8.\n\nThese patterns will advance the `Position {line}` by 1 and reset\nthe `Position {column}` to 1:\n- newline (`0x0A`)\n- carriage-return (`0x0D`)\n- carriage-return-newline (`0x0D 0x0A`)\n","declarations":[{"kind":null,"children":[],"comments":"Match the specified BMP `Char`.\n","title":"char","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]}]},null]}},"sourceSpan":{"start":[142,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String.purs","end":[142,48]}},{"kind":null,"children":[],"comments":"Match the specified string.\n","title":"string","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]}]},null]}},"sourceSpan":{"start":[87,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String.purs","end":[87,54]}},{"kind":null,"children":[],"comments":"Match any BMP `Char`.\nParser will fail if the character is not in the Basic Multilingual Plane.\n","title":"anyChar","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]},null]}},"sourceSpan":{"start":[97,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String.purs","end":[97,43]}},{"kind":null,"children":[],"comments":"Match any Unicode character.\nAlways succeeds when any input remains.\n","title":"anyCodePoint","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","String","CodePoints"],"CodePoint"]}]},null]}},"sourceSpan":{"start":[102,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String.purs","end":[102,53]}},{"kind":null,"children":[],"comments":"Match a BMP `Char` satisfying the predicate.\n","title":"satisfy","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]}]},null]}},"sourceSpan":{"start":[106,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String.purs","end":[106,64]}},{"kind":null,"children":[],"comments":"Match a Unicode character satisfying the predicate.\n","title":"satisfyCodePoint","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","String","CodePoints"],"CodePoint"]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","String","CodePoints"],"CodePoint"]}]}]},null]}},"sourceSpan":{"start":[128,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String.purs","end":[128,83]}},{"kind":null,"children":[],"comments":"Match a `String` exactly *N* characters long.\n","title":"takeN","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]}]},null]}},"sourceSpan":{"start":[146,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String.purs","end":[146,50]}},{"kind":null,"children":[],"comments":"Match the entire rest of the input stream. Always succeeds.\n","title":"rest","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},null]}},"sourceSpan":{"start":[82,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String.purs","end":[82,42]}},{"kind":null,"children":[],"comments":"Match “end-of-file,” the end of the input stream.\n","title":"eof","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]},null]}},"sourceSpan":{"start":[71,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String.purs","end":[71,39]}},{"kind":null,"children":[],"comments":"Combinator which returns both the result of a parse and the slice of\nthe input that was consumed while it was being parsed.\n\nBecause `String`s are not `Char` arrays in PureScript, `many` and `some`\non `Char` parsers need to\nbe used with `Data.String.CodeUnits.fromCharArray` to\nconstruct a `String`.\n\n```\nfromCharArray <$> Data.Array.many (char 'x')\n```\n\nIt’s more efficient to achieve the same result by using this `match` combinator\ninstead of `fromCharArray`.\n\n```\nfst <$> match (Combinators.skipMany (char 'x'))\n```\n","title":"match","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]}]},null]},null]}},"sourceSpan":{"start":[195,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String.purs","end":[195,77]}},{"kind":null,"children":[],"comments":"Compile a regular expression string into a regular expression parser.\n\nThis function will use the `Data.String.Regex.regex` function to compile and return a parser which can be used\nin a `ParserT String m` monad.\n\nThis parser will try to match the regular expression pattern starting\nat the current parser position. On success, it will return the matched\nsubstring.\n\n[*MDN Regular Expressions Cheatsheet*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Cheatsheet)\n\nThis function should be called outside the context of a `ParserT String m` monad, because this function might\nfail with a `Left` RegExp compilation error message.\nIf you call this function inside of the `ParserT String m` monad and then `fail` the parse when the compilation fails,\nthen that could be confusing because a parser failure is supposed to indicate an invalid input string.\nIf the compilation failure occurs in an `alt` then the compilation failure might not be reported at all and instead\nthe input string would be parsed incorrectly.\n\nThis parser may be useful for quickly consuming a large section of the\ninput `String`, because in a JavaScript runtime environment the RegExp\nruntime is a lot faster than primitive parsers.\n\n#### Example\n\nThis example shows how to compile and run the `xMany` parser which will\ncapture the regular expression pattern `x*`.\n\n```purescript\ncase regex \"x*\" noFlags of\n  Left compileError -> unsafeCrashWith $ \"xMany failed to compile: \" <> compileError\n  Right xMany -> runParser \"xxxZ\" do\n    xMany\n```\n\n#### Flags\n\nSet `RegexFlags` with the `Semigroup` instance like this.\n\n```purescript\nregex \"x*\" (dotAll <> ignoreCase)\n```\n\nThe `dotAll`, `unicode`, and `ignoreCase` flags might make sense for a `regex` parser. The other flags will\nprobably cause surprising behavior and you should avoid them.\n\n[*MDN Advanced searching with flags*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#advanced_searching_with_flags)\n","title":"regex","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","String","Regex","Flags"],"RegexFlags"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Either"],"Either"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]}}]}]}]},null]}},"sourceSpan":{"start":[253,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String.purs","end":[253,83]}},{"kind":null,"children":[],"comments":"Combinator which finds the first position in the input `String` where the\nphrase can parse. Returns both the\nparsed result and the unparsable input section searched before the parse.\nWill fail if no section of the input is parseable. To backtrack the input\nstream on failure, combine with `tryRethrow`.\n\nThis combinator works like\n[Data.String.takeWhile](https://pursuit.purescript.org/packages/purescript-strings/docs/Data.String#v:takeWhile)\nor\n[Data.String.Regex.search](https://pursuit.purescript.org/packages/purescript-strings/docs/Data.String.Regex#v:search)\nand it allows using a parser for the pattern search.\n\nThis combinator is equivalent to `manyTill_ anyCodePoint`, but it will be\nfaster because it returns a slice of the input `String` for the\nsection preceding the parse instead of a `List CodePoint`.\n\nBe careful not to look too far\nahead; if the phrase parser looks to the end of the input then `anyTill`\ncould be *O(n²)*.\n","title":"anyTill","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Control","Monad"],"Monad"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"m"}],"constraintKindArgs":[],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]}]}]},null]},null]}},"sourceSpan":{"start":[306,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String.purs","end":[310,39]}},{"kind":null,"children":[],"comments":"Consume a portion of the input string while yielding a value.\n\nTakes a consumption function which takes the remaining input `String`\nas its argument and returns either an error message, or three fields:\n\n* `value` is the value to return.\n* `consumed` is the input `String` that was consumed. It is used to update the parser position.\n* `remainder` is the new remaining input `String`.\n\nThis function is used internally to construct primitive `String` parsers.\n","title":"consumeWith","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Either"],"Either"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Record"]},{"annotation":[],"tag":"RCons","contents":["value",{"annotation":[],"tag":"TypeVar","contents":"a"},{"annotation":[],"tag":"RCons","contents":["consumed",{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]},{"annotation":[],"tag":"RCons","contents":["remainder",{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]},{"annotation":[],"tag":"REmpty"}]}]}]}]}]}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},null]},null]}},"sourceSpan":{"start":[274,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String.purs","end":[277,24]}}]},{"reExports":[],"name":"Parsing.String.Basic","comments":"Basic `String` parsers derived from primitive `String` parsers.\n","declarations":[{"kind":null,"children":[],"comments":"Parse a digit.  Matches any char that satisfies `Data.CodePoint.Unicode.isDecDigit`.\n","title":"digit","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]},null]}},"sourceSpan":{"start":[40,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String/Basic.purs","end":[40,41]}},{"kind":null,"children":[],"comments":"Parse a hex digit.  Matches any char that satisfies `Data.CodePoint.Unicode.isHexDigit`.\n","title":"hexDigit","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]},null]}},"sourceSpan":{"start":[44,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String/Basic.purs","end":[44,44]}},{"kind":null,"children":[],"comments":"Parse an octal digit.  Matches any char that satisfies `Data.CodePoint.Unicode.isOctDigit`.\n","title":"octDigit","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]},null]}},"sourceSpan":{"start":[48,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String/Basic.purs","end":[48,44]}},{"kind":null,"children":[],"comments":"Parse an alphabetical character.  Matches any char that satisfies `Data.CodePoint.Unicode.isAlpha`.\n","title":"letter","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]},null]}},"sourceSpan":{"start":[64,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String/Basic.purs","end":[64,42]}},{"kind":null,"children":[],"comments":"Parse a space character.  Matches any char that satisfies `Data.CodePoint.Unicode.isSpace`.\n","title":"space","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]},null]}},"sourceSpan":{"start":[60,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String/Basic.purs","end":[60,41]}},{"kind":null,"children":[],"comments":"Parse a lowercase letter.  Matches any char that satisfies `Data.CodePoint.Unicode.isLower`.\n","title":"lower","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]},null]}},"sourceSpan":{"start":[52,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String/Basic.purs","end":[52,41]}},{"kind":null,"children":[],"comments":"Parse an uppercase letter.  Matches any char that satisfies `Data.CodePoint.Unicode.isUpper`.\n","title":"upper","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]},null]}},"sourceSpan":{"start":[56,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String/Basic.purs","end":[56,41]}},{"kind":null,"children":[],"comments":"Parse an alphabetical or numerical character.\nMatches any char that satisfies `Data.CodePoint.Unicode.isAlphaNum`.\n","title":"alphaNum","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]},null]}},"sourceSpan":{"start":[69,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String/Basic.purs","end":[69,44]}},{"kind":null,"children":[],"comments":"Parser based on the __Data.Int.fromString__ function.\n\nThis should be the inverse of `show :: String -> Int`.\n\nExamples of strings which can be parsed by this parser:\n* `\"3\"`\n* `\"-3\"`\n* `\"+300\"`\n","title":"intDecimal","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]},null]}},"sourceSpan":{"start":[117,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String/Basic.purs","end":[117,45]}},{"kind":null,"children":[],"comments":"Parser based on the __Data.Number.fromString__ function.\n\nThis should be the inverse of `show :: String -> Number`.\n\nExamples of strings which can be parsed by this parser:\n* `\"3\"`\n* `\"3.0\"`\n* `\"0.3\"`\n* `\"-0.3\"`\n* `\"+0.3\"`\n* `\"-3e-1\"`\n* `\"-3.0E-1.0\"`\n* `\"NaN\"`\n* `\"-Infinity\"`\n","title":"number","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Number"]}]},null]}},"sourceSpan":{"start":[86,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String/Basic.purs","end":[86,44]}},{"kind":null,"children":[],"comments":"Match zero or more whitespace characters satisfying\n`Data.CodePoint.Unicode.isSpace`. Always succeeds.\n","title":"whiteSpace","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},null]}},"sourceSpan":{"start":[135,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String/Basic.purs","end":[135,48]}},{"kind":null,"children":[],"comments":"Skip whitespace characters and throw them away. Always succeeds.\n","title":"skipSpaces","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]},null]}},"sourceSpan":{"start":[139,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String/Basic.purs","end":[139,46]}},{"kind":null,"children":[],"comments":"Match one of the BMP `Char`s in the array.\n","title":"oneOf","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Array"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]}]},null]}},"sourceSpan":{"start":[146,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String/Basic.purs","end":[146,55]}},{"kind":null,"children":[],"comments":"Match one of the Unicode characters in the array.\n","title":"oneOfCodePoints","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Array"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","String","CodePoints"],"CodePoint"]}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","String","CodePoints"],"CodePoint"]}]}]},null]}},"sourceSpan":{"start":[154,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String/Basic.purs","end":[154,75]}},{"kind":null,"children":[],"comments":"Match any BMP `Char` not in the array.\n","title":"noneOf","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Array"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]}]},null]}},"sourceSpan":{"start":[150,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String/Basic.purs","end":[150,56]}},{"kind":null,"children":[],"comments":"Match any Unicode character not in the array.\n","title":"noneOfCodePoints","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Array"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","String","CodePoints"],"CodePoint"]}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","String","CodePoints"],"CodePoint"]}]}]},null]}},"sourceSpan":{"start":[158,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String/Basic.purs","end":[158,76]}}]},{"reExports":[],"name":"Parsing.String.Replace","comments":"This module is for finding patterns in a `String`, and also\nreplacing or splitting on the found patterns.\nThis activity is traditionally done with\n[__Regex__](https://pursuit.purescript.org/packages/purescript-strings/docs/Data.String.Regex),\nbut this module uses parsers instead for the pattern matching.\n\nFunctions in this module are *ways to run a parser* on an input `String`,\nlike `runParser` or `runParserT`.\n\n#### Why would we want to do pattern matching and substitution with parsers instead of regular expressions?\n\n* Monadic parsers have a nicer syntax than\n  [regular expressions](https://en.wikipedia.org/wiki/Regular_expression),\n  which are notoriously\n  [difficult to read](https://en.wikipedia.org/wiki/Write-only_language).\n  With monadic parsers we can perform textual pattern-matching in plain\n  PureScript rather than using a special regex domain-specific\n  programming language.\n\n* Regular expressions can do “group capture” on sections of the matched\n  pattern, but they can only return stringy lists of the capture groups. Parsers\n  can construct typed data structures based on the capture groups, guaranteeing\n  no disagreement between the pattern rules and the rules that we're using\n  to build data structures based on the pattern matches.\n\n  For example, consider\n  scanning a string for numbers. A lot of different things can look like a number,\n  and can have leading plus or minus signs, or be in scientific notation, or\n  have commas, or whatever. If we try to parse all of the numbers out of a string\n  using regular expressions, then we have to make sure that the regular expression\n  and the string-to-number conversion function agree about exactly what is\n  and what isn't a numeric string. We can get into an awkward situation in which\n  the regular expression says it has found a numeric string but the\n  string-to-number conversion function fails. A typed parser will perform both\n  the pattern match and the conversion, so it will never be in that situation.\n  [Parse, don't validate.](https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/)\n\n* Regular expressions are only able to pattern-match\n  [regular grammars](https://en.wikipedia.org/wiki/Chomsky_hierarchy#The_hierarchy).\n  Monadic parsers are able pattern-match context-free (by recursion)\n  or context-sensitive (by monad transformer) grammars.\n\n* The replacement expression for a traditional regular expression-based\n  substitution command is usually just a string template in which\n  the *Nth* “capture group” can be inserted with the syntax `\\N`. With\n  this library, instead of a template, we get\n  an `editor` function which can perform any computation, including `Effect`s.\n\n#### Implementation Notes\n\nAll of the functions in this module work by calling `runParserT`\nwith the `anyTill` combinator.\nWe can expect the speed of parser-based pattern matching to be\nabout 10× worse than regex-based pattern matching in a JavaScript\nruntime environment.\nThis module is based on the Haskell packages\n[__replace-megaparsec__](https://hackage.haskell.org/package/replace-megaparsec)\nand\n[__replace-attoparsec__](https://hackage.haskell.org/package/replace-attoparsec).\n\n","declarations":[{"kind":null,"children":[],"comments":"#### Break on and capture one pattern\n\nFind the first occurence of a pattern in a text stream, capture the found\npattern, and break the input text stream on the found pattern.\n\nThis function can be used instead of\n[Data.String.indexOf](https://pursuit.purescript.org/packages/purescript-strings/docs/Data.String#v:indexOf)\nor\n[Data.String.Regex.search](https://pursuit.purescript.org/packages/purescript-strings/docs/Data.String.Regex#v:search)\nor\n[Data.String.Regex.replace](https://pursuit.purescript.org/packages/purescript-strings/docs/Data.String.Regex#v:replace)\nand it allows using a parser for the pattern search.\n\nThis function can be used instead of\n[Data.String.takeWhile](https://pursuit.purescript.org/packages/purescript-strings/docs/Data.String#v:takeWhile)\nor\n[Data.String.dropWhile](https://pursuit.purescript.org/packages/purescript-strings/docs/Data.String#v:dropWhile)\nand it is predicated beyond more than just the next single `CodePoint`.\n\n#### Output\n\n- `Nothing` when no pattern match was found.\n- `Just (prefix /\\ parse_result /\\ suffix)` for the result of parsing the\n  pattern match, and the `prefix` string before and the `suffix` string\n  after the pattern match. `prefix` and `suffix` may be zero-length strings.\n\n#### Access the matched section of text\n\nIf you want to capture the matched string, then combine the pattern\nparser `sep` with `match`.\n\nWith the matched string, we can reconstruct the input string.\nFor all `input`, `sep`, if\n\n```purescript\nlet (Just (prefix /\\ (infix /\\ _) /\\ suffix)) =\n      breakCap input (match sep)\n```\n\nthen\n\n```purescript\ninput == prefix <> infix <> suffix\n```\n#### Example\n\nFind the first pattern match and break the input string on the pattern.\n\n```purescript\nbreakCap \"hay needle hay\" (string \"needle\")\n```\n\nResult:\n\n```purescript\nJust (\"hay \" /\\ \"needle\" /\\ \" hay\")\n```\n\n#### Example\n\nFind the first pattern match, capture the matched text and the parsed result.\n\n```purescript\nbreakCap \"abc 123 def\" (match intDecimal)\n```\n\nResult:\n\n```purescript\nJust (\"abc \" /\\ (\"123\" /\\ 123) /\\ \" def\")\n```\n","title":"breakCap","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"Parser"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple","Nested"],"T3"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]}}]}]}]},null]}},"sourceSpan":{"start":[186,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String/Replace.purs","end":[190,32]}},{"kind":null,"children":[],"comments":"Monad transformer version of `breakCap`. The `sep` parser will run\nin the monad context.\n","title":"breakCapT","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Control","Monad"],"Monad"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"m"}],"constraintKindArgs":[],"constraintData":null},{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Control","Monad","Rec","Class"],"MonadRec"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"m"}],"constraintKindArgs":[],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"m"},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple","Nested"],"T3"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]}}]}}]}]}]}]}]},null]},null]}},"sourceSpan":{"start":[100,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String/Replace.purs","end":[106,36]}},{"kind":null,"children":[],"comments":"#### Split on and capture all patterns\n\nFind all occurences of the pattern parser `sep`, split the input string,\ncapture all the patterns and the splits.\n\nThis function can be used instead of\n[Data.String.Common.split](https://pursuit.purescript.org/packages/purescript-strings/docs/Data.String.Common#v:split)\nor\n[Data.String.Regex.split](https://pursuit.purescript.org/packages/purescript-strings/docs/Data.String.Regex#v:split)\nor\n[Data.String.Regex.match](https://pursuit.purescript.org/packages/purescript-strings/docs/Data.String.Regex#v:match)\nor\n[Data.String.Regex.search](https://pursuit.purescript.org/packages/purescript-strings/docs/Data.String.Regex#v:search).\n\nThe input string will be split on every leftmost non-overlapping occurence\nof the pattern `sep`. The output list will contain\nthe parsed result of input string sections which match the `sep` pattern\nin `Right`, and non-matching sections in `Left`.\n\n#### Access the matched section of text\n\nIf you want to capture the matched strings, then combine the pattern\nparser `sep` with the `match` combinator.\n\nWith the matched strings, we can reconstruct the input string.\nFor all `input`, `sep`, if\n\n```purescript\nlet output = splitCap input (match sep)\n```\n\nthen\n\n```purescript\ninput == fold (either identity fst <$> output)\n```\n\n#### Example\n\nSplit the input string on all `Int` pattern matches.\n\n```purescript\nsplitCap \"hay 1 straw 2 hay\" intDecimal\n```\n\nResult:\n\n```\n[Left \"hay \", Right 1, Left \" straw \", Right 2, Left \" hay\"]\n```\n\n#### Example\n\nFind the beginning positions of all pattern matches in the input.\n\n```purescript\ncatMaybes $ hush <$> splitCap \".𝝺...\\n...𝝺.\" (position <* string \"𝝺\")\n```\n\nResult:\n\n```purescript\n[ Position {index: 1, line: 1, column: 2 }\n, Position { index: 9, line: 2, column: 4 }\n]\n```\n\n#### Example\n\nFind groups of balanced nested parentheses. This pattern is an example of\na “context-free” grammar, a pattern that\n[can't be expressed by a regular expression](https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454).\nWe can express the pattern with a recursive parser.\n\n```purescript\nbalancedParens :: Parser String Unit\nbalancedParens = do\n  void $ char '('\n  void $ manyTill (balancedParens <|> void anyCodePoint) (char ')')\n\nrmap fst <$> splitCap \"((🌼)) (()())\" (match balancedParens)\n```\n\nResult:\n\n```purescript\n[Right \"((🌼))\", Left \" \", Right \"(()())\"]\n```\n","title":"splitCap","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"Parser"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"NonEmptyList"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Either"],"Either"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]}]}]},null]}},"sourceSpan":{"start":[406,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String/Replace.purs","end":[410,36]}},{"kind":null,"children":[],"comments":"Monad transformer version of `splitCap`. The `sep` parser will run in the\nmonad context.\n\n#### Example\n\nCount the pattern matches.\n\nParse in a `State` monad to remember state in the parser. This\nstateful `letterCount` parser counts\nthe number of pattern matches which occur in the input, and also\ntags each match with its index.\n\n\n```purescript\nletterCount :: ParserT String (State Int) (Tuple Char Int)\nletterCount = do\n  x <- letter\n  i <- modify (_+1)\n  pure (x /\\ i)\n\nflip runState 0 $ splitCapT \"A B\" letterCount\n```\n\nResult:\n\n```purescript\n[Right ('A' /\\ 1), Left \" \", Right ('B' /\\ 2)] /\\ 2\n```\n","title":"splitCapT","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Control","Monad"],"Monad"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"m"}],"constraintKindArgs":[],"constraintData":null},{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Control","Monad","Rec","Class"],"MonadRec"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"m"}],"constraintKindArgs":[],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"m"},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"NonEmptyList"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Either"],"Either"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]}}]}]}]}]}]},null]},null]}},"sourceSpan":{"start":[221,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String/Replace.purs","end":[227,40]}},{"kind":null,"children":[],"comments":"\n#### Find-and-replace\n\nAlso called “match-and-substitute”. Find all\nof the leftmost non-overlapping sections of the input string which match\nthe pattern parser `sep`, and\nreplace them with the result of the parser.\nThe `sep` parser must return a result of type `String`.\n\nThis function can be used instead of\n[Data.String.replaceAll](https://pursuit.purescript.org/packages/purescript-strings/docs/Data.String#v:replaceAll)\nor\n[Data.String.Regex.replace'](https://pursuit.purescript.org/packages/purescript-strings/docs/Data.String.Regex#v:replace').\n\n#### Access the matched section of text in the `editor`\n\nTo get access to the matched string for the replacement\ncombine the pattern parser `sep`\nwith `match`.\nThis allows us to write a `sep` parser which can choose to not\nedit the match and just leave it as it is.\n\nSo, for all `sep`:\n\n```purescript\nreplace input (fst <$> match sep) == input\n```\n\n#### Example\n\nFind and uppercase the `\"needle\"` pattern.\n\n```purescript\nreplace \"hay needle hay\" (toUpper <$> string \"needle\")\n```\n\nResult:\n\n```purescript\n\"hay NEEDLE hay\"\n```\n\n#### Example\n\nFind integers and double them.\n\n```purescript\nreplace \"1 6 21 107\" (show <$> (_*2) <$> intDecimal)\n```\n\nResult:\n\n```purescript\n\"2 12 42 214\"\n```\n","title":"replace","info":{"declType":"value","type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"Parser"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]}]}},"sourceSpan":{"start":[542,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String/Replace.purs","end":[545,12]}},{"kind":null,"children":[],"comments":"Monad transformer version of `replace`.\n\n#### Example\n\nFind an environment variable in curly braces and replace it with its value\nfrom the environment.\nWe can read from the environment with `lookupEnv` because `replaceT` is\nrunning the `sep` parser in `Effect`.\n\n```purescript\nreplaceT \"◀ {HOME} ▶\" do\n  _ <- string \"{\"\n  Tuple home _ <- anyTill (string \"}\")\n  lift (lookupEnv home) >>= maybe empty pure\n```\n\nResult:\n\n```purescript\n\"◀ /home/jbrock ▶\"\n```\n\n[![Perl Problems](https://imgs.xkcd.com/comics/perl_problems.png)](https://xkcd.com/1171/)\n","title":"replaceT","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Control","Monad"],"Monad"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"m"}],"constraintKindArgs":[],"constraintData":null},{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Control","Monad","Rec","Class"],"MonadRec"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"m"}],"constraintKindArgs":[],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"m"},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]}]}]}]}]},null]}},"sourceSpan":{"start":[436,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String/Replace.purs","end":[442,14]}}]},{"reExports":[{"moduleName":{"package":null,"item":["Parsing","String","Basic"]},"declarations":[{"kind":null,"children":[],"comments":"Parse an uppercase letter.  Matches any char that satisfies `Data.CodePoint.Unicode.isUpper`.\n","title":"upper","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]},null]}},"sourceSpan":{"start":[56,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String/Basic.purs","end":[56,41]}},{"kind":null,"children":[],"comments":"Parse a space character.  Matches any char that satisfies `Data.CodePoint.Unicode.isSpace`.\n","title":"space","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]},null]}},"sourceSpan":{"start":[60,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String/Basic.purs","end":[60,41]}},{"kind":null,"children":[],"comments":"Match one of the BMP `Char`s in the array.\n","title":"oneOf","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Array"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]}]},null]}},"sourceSpan":{"start":[146,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String/Basic.purs","end":[146,55]}},{"kind":null,"children":[],"comments":"Parse an octal digit.  Matches any char that satisfies `Data.CodePoint.Unicode.isOctDigit`.\n","title":"octDigit","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]},null]}},"sourceSpan":{"start":[48,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String/Basic.purs","end":[48,44]}},{"kind":null,"children":[],"comments":"Match any BMP `Char` not in the array.\n","title":"noneOf","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Array"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]}]},null]}},"sourceSpan":{"start":[150,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String/Basic.purs","end":[150,56]}},{"kind":null,"children":[],"comments":"Parse an alphabetical character.  Matches any char that satisfies `Data.CodePoint.Unicode.isAlpha`.\n","title":"letter","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]},null]}},"sourceSpan":{"start":[64,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String/Basic.purs","end":[64,42]}},{"kind":null,"children":[],"comments":"Parse a hex digit.  Matches any char that satisfies `Data.CodePoint.Unicode.isHexDigit`.\n","title":"hexDigit","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]},null]}},"sourceSpan":{"start":[44,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String/Basic.purs","end":[44,44]}},{"kind":null,"children":[],"comments":"Parse a digit.  Matches any char that satisfies `Data.CodePoint.Unicode.isDecDigit`.\n","title":"digit","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]},null]}},"sourceSpan":{"start":[40,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String/Basic.purs","end":[40,41]}},{"kind":null,"children":[],"comments":"Parse an alphabetical or numerical character.\nMatches any char that satisfies `Data.CodePoint.Unicode.isAlphaNum`.\n","title":"alphaNum","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]},null]}},"sourceSpan":{"start":[69,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/String/Basic.purs","end":[69,44]}}]}],"name":"Parsing.Token","comments":"Primitive parsers for an input stream of type\n`(`[__List__](https://pursuit.purescript.org/packages/purescript-lists/docs/Data.List.Types#t:List) `a)`\nfor working with streams of tokens.\n\nThis module is a port of the Haskell\n[__Text.Parsec.Token__](https://hackage.haskell.org/package/parsec/docs/Text-Parsec-Token.html)\nmodule.\n","declarations":[{"kind":null,"children":[],"comments":"A parser which returns the first token in the stream.\n","title":"token","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"Position"]}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"List"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},null]},null]}},"sourceSpan":{"start":[52,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Token.purs","end":[52,61]}},{"kind":null,"children":[],"comments":"A parser which matches any token satisfying the predicate.\n","title":"when","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"Position"]}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"List"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}]},null]},null]}},"sourceSpan":{"start":[62,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Token.purs","end":[62,78]}},{"kind":null,"children":[],"comments":"Match the specified token at the head of the stream.\n","title":"match","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Eq"],"Eq"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintKindArgs":[],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"Position"]}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"List"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}]}]},null]},null]}},"sourceSpan":{"start":[69,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Token.purs","end":[69,74]}},{"kind":null,"children":[],"comments":"Match the “end-of-file,” the end of the input stream.\n","title":"eof","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"List"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]},null]},null]}},"sourceSpan":{"start":[73,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Token.purs","end":[73,43]}},{"kind":null,"children":[],"comments":null,"title":"LanguageDef","info":{"arguments":[],"declType":"typeSynonym","type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Token"],"GenLanguageDef"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Identity"],"Identity"]}]}},"sourceSpan":{"start":[81,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Token.purs","end":[81,50]}},{"kind":{"kind":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Type"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Type"]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Type"]}]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Type"]}]}]},"keyword":"newtype"},"children":[{"comments":null,"title":"LanguageDef","info":{"arguments":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Record"]},{"annotation":[],"tag":"RCons","contents":["commentStart",{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]},{"annotation":[],"tag":"RCons","contents":["commentEnd",{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]},{"annotation":[],"tag":"RCons","contents":["commentLine",{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]},{"annotation":[],"tag":"RCons","contents":["nestedComments",{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]},{"annotation":[],"tag":"RCons","contents":["identStart",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]},{"annotation":[],"tag":"RCons","contents":["identLetter",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]},{"annotation":[],"tag":"RCons","contents":["opStart",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]},{"annotation":[],"tag":"RCons","contents":["opLetter",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]},{"annotation":[],"tag":"RCons","contents":["reservedNames",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Array"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"RCons","contents":["reservedOpNames",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Array"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"RCons","contents":["caseSensitive",{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]},{"annotation":[],"tag":"REmpty"}]}]}]}]}]}]}]}]}]}]}]}]}],"declType":"dataConstructor"},"sourceSpan":{"start":[86,28],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Token.purs","end":[129,4]}}],"comments":"The `GenLanguageDef` type is a record that contains all parameterizable\nfeatures of the \"Text.Parsec.Token\" module. The module `Text.Parsec.Language`\ncontains some default definitions.\n","title":"GenLanguageDef","info":{"declType":"data","dataDeclType":"newtype","typeArguments":[["s",null],["m",null]]},"sourceSpan":{"start":[86,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Token.purs","end":[129,4]}},{"kind":null,"children":[],"comments":null,"title":"unGenLanguageDef","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["s",{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Token"],"GenLanguageDef"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Record"]},{"annotation":[],"tag":"RCons","contents":["caseSensitive",{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]},{"annotation":[],"tag":"RCons","contents":["reservedOpNames",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Array"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"RCons","contents":["reservedNames",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Array"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"RCons","contents":["opLetter",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]},{"annotation":[],"tag":"RCons","contents":["opStart",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]},{"annotation":[],"tag":"RCons","contents":["identLetter",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]},{"annotation":[],"tag":"RCons","contents":["identStart",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]},{"annotation":[],"tag":"RCons","contents":["nestedComments",{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]},{"annotation":[],"tag":"RCons","contents":["commentLine",{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]},{"annotation":[],"tag":"RCons","contents":["commentEnd",{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]},{"annotation":[],"tag":"RCons","contents":["commentStart",{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]},{"annotation":[],"tag":"REmpty"}]}]}]}]}]}]}]}]}]}]}]}]}]},null]},null]}},"sourceSpan":{"start":[131,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Token.purs","end":[145,7]}},{"kind":null,"children":[],"comments":null,"title":"TokenParser","info":{"arguments":[],"declType":"typeSynonym","type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Token"],"GenTokenParser"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Identity"],"Identity"]}]}},"sourceSpan":{"start":[152,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Token.purs","end":[152,50]}},{"kind":{"kind":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Type"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Type"]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Type"]}]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Type"]}]}]},"keyword":"type"},"children":[],"comments":"The type of the record that holds lexical parsers that work on\n`s` streams over a monad `m`.\n","title":"GenTokenParser","info":{"arguments":[["s",null],["m",null]],"declType":"typeSynonym","type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Record"]},{"annotation":[],"tag":"RCons","contents":["identifier",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"RCons","contents":["reserved",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]}]},{"annotation":[],"tag":"RCons","contents":["operator",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"RCons","contents":["reservedOp",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]}]},{"annotation":[],"tag":"RCons","contents":["charLiteral",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]},{"annotation":[],"tag":"RCons","contents":["stringLiteral",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"RCons","contents":["natural",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]},{"annotation":[],"tag":"RCons","contents":["integer",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]},{"annotation":[],"tag":"RCons","contents":["float",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Number"]}]},{"annotation":[],"tag":"RCons","contents":["naturalOrFloat",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Either"],"Either"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Number"]}]}}]},{"annotation":[],"tag":"RCons","contents":["decimal",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]},{"annotation":[],"tag":"RCons","contents":["hexadecimal",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]},{"annotation":[],"tag":"RCons","contents":["octal",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]},{"annotation":[],"tag":"RCons","contents":["symbol",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]}]},{"annotation":[],"tag":"RCons","contents":["lexeme",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},null]},{"annotation":[],"tag":"RCons","contents":["whiteSpace",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]},{"annotation":[],"tag":"RCons","contents":["parens",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},null]},{"annotation":[],"tag":"RCons","contents":["braces",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},null]},{"annotation":[],"tag":"RCons","contents":["angles",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},null]},{"annotation":[],"tag":"RCons","contents":["brackets",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},null]},{"annotation":[],"tag":"RCons","contents":["semi",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"RCons","contents":["comma",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"RCons","contents":["colon",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"RCons","contents":["dot",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"RCons","contents":["semiSep",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"List"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]}]},null]},{"annotation":[],"tag":"RCons","contents":["semiSep1",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"NonEmptyList"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]}]},null]},{"annotation":[],"tag":"RCons","contents":["commaSep",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"List"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]}]},null]},{"annotation":[],"tag":"RCons","contents":["commaSep1",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"annotation":[],"tag":"TypeVar","contents":"s"}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","List","Types"],"NonEmptyList"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]}]},null]},{"annotation":[],"tag":"REmpty"}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}},"sourceSpan":{"start":[156,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Token.purs","end":[321,4]}},{"kind":null,"children":[],"comments":"The expression `makeTokenParser language` creates a `GenTokenParser`\nrecord that contains lexical parsers that are\ndefined using the definitions in the `language` record.\n\nThe use of this function is quite stylized - one imports the\nappropiate language definition and selects the lexical parsers that\nare needed from the resulting `GenTokenParser`.\n\n```purescript\nmodule Main where\n\nimport Parsing.Language (haskellDef)\nimport Parsing.Token (makeTokenParser)\n\n-- The parser\nexpr = parens expr\n   <|> identifier\n   <|> ...\n\n\n-- The lexer\ntokenParser = makeTokenParser haskellDef\nparens      = tokenParser.parens\nbraces      = tokenParser.braces\nidentifier  = tokenParser.identifier\nreserved    = tokenParser.reserved\n...\n```\n","title":"makeTokenParser","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["m",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Token"],"GenLanguageDef"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Parsing","Token"],"GenTokenParser"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeVar","contents":"m"}]}]},null]}},"sourceSpan":{"start":[355,1],"name":"/home/jordan/Programming/ps-libs/lib/parsing/src/Parsing/Token.purs","end":[355,80]}}]}],"resolvedDependencies":{"purescript-exceptions":"6.0.0","purescript-newtype":"5.0.0","purescript-effect":"4.0.0","purescript-unicode":"6.0.0","purescript-control":"6.0.0","purescript-arraybuffer-types":"3.0.2","purescript-console":"6.0.0","purescript-either":"6.0.0","purescript-node-streams":"6.0.0","purescript-profunctor":"6.0.0","purescript-arrays":"7.0.0","purescript-maybe":"6.0.0","purescript-type-equality":"4.0.1","purescript-exists":"6.0.0","purescript-distributive":"6.0.0","purescript-unfoldable":"6.0.0","purescript-invariant":"6.0.0","purescript-lazy":"6.0.0","purescript-foreign-object":"4.0.0","purescript-node-process":"9.0.0","purescript-foldable-traversable":"6.0.0","purescript-tailrec":"6.0.0","purescript-gen":"4.0.0","purescript-typelevel-prelude":"7.0.0","purescript-functors":"5.0.0","purescript-prelude":"6.0.0","purescript-st":"6.0.0","purescript-bifunctors":"6.0.0","purescript-nonempty":"7.0.0","purescript-contravariant":"6.0.0","purescript-assert":"6.0.0","purescript-unsafe-coerce":"6.0.0","purescript-refs":"6.0.0","purescript-integers":"6.0.0","purescript-orders":"6.0.0","purescript-const":"6.0.0","purescript-node-buffer":"8.0.0","purescript-transformers":"6.0.0","purescript-numbers":"9.0.0","purescript-enums":"6.0.0","purescript-posix-types":"6.0.0","purescript-tuples":"7.0.0","purescript-partial":"4.0.0","purescript-strings":"6.0.0","purescript-identity":"6.0.0","purescript-safe-coerce":"2.0.0","purescript-lists":"7.0.0","purescript-nullable":"6.0.0","purescript-functions":"6.0.0"},"version":"9.0.0","github":["purescript-contrib","purescript-parsing"],"versionTag":"v9.0.0","moduleMap":{"Data.BooleanAlgebra":"purescript-prelude","Data.Decide":"purescript-contravariant","Type.Data.Boolean":"purescript-typelevel-prelude","Data.Ring":"purescript-prelude","Data.Semigroup.Generic":"purescript-prelude","Control.Monad.Trans.Class":"purescript-transformers","Data.Functor.Product":"purescript-functors","Type.Function":"purescript-typelevel-prelude","Data.Functor.Flip":"purescript-functors","Data.NonEmpty":"purescript-nonempty","Effect.Uncurried":"purescript-effect","Control.Monad.Identity.Trans":"purescript-transformers","Data.Char.Gen":"purescript-strings","Data.Monoid.Generic":"purescript-prelude","Data.String.NonEmpty":"purescript-strings","Effect":"purescript-effect","Data.Traversable.Accum.Internal":"purescript-foldable-traversable","Data.CodePoint.Unicode.Internal":"purescript-unicode","Data.Enum.Gen":"purescript-enums","Data.Nullable":"purescript-nullable","Control.Comonad.Env":"purescript-transformers","Control.Comonad.Traced.Class":"purescript-transformers","Data.Functor.Costar":"purescript-functors","Data.HeytingAlgebra.Generic":"purescript-prelude","Data.Functor.Compose":"purescript-functors","Foreign.Object.Gen":"purescript-foreign-object","Type.Row.Homogeneous":"purescript-typelevel-prelude","Node.Buffer.ST":"purescript-node-buffer","Data.Int.Bits":"purescript-integers","Data.String.CodePoints":"purescript-strings","Data.Ord":"purescript-prelude","Control.Monad.Gen":"purescript-gen","Data.Bounded.Generic":"purescript-prelude","Safe.Coerce":"purescript-safe-coerce","Data.Monoid.Dual":"purescript-prelude","Control.Monad.Rec.Class":"purescript-tailrec","Data.Bitraversable":"purescript-foldable-traversable","Data.Boolean":"purescript-prelude","Data.Show.Generic":"purescript-prelude","Control.Biapplicative":"purescript-bifunctors","Effect.Exception.Unsafe":"purescript-exceptions","Data.Array.NonEmpty.Internal":"purescript-arrays","Type.Proxy":"purescript-prelude","Data.String.Unicode":"purescript-unicode","Data.Array.ST.Iterator":"purescript-arrays","Data.Enum.Generic":"purescript-enums","Data.String.Pattern":"purescript-strings","Data.Bounded":"purescript-prelude","Control.Monad.State.Trans":"purescript-transformers","Data.TraversableWithIndex":"purescript-foldable-traversable","Node.Encoding":"purescript-node-buffer","Data.Int":"purescript-integers","Data.Profunctor.Cochoice":"purescript-profunctor","Data.Show":"purescript-prelude","Control.Monad.Writer.Trans":"purescript-transformers","Data.Foldable":"purescript-foldable-traversable","Data.Divide":"purescript-contravariant","Control.Comonad.Store.Class":"purescript-transformers","Data.Number":"purescript-numbers","Data.Enum":"purescript-enums","Foreign.Object":"purescript-foreign-object","Control.Apply":"purescript-prelude","Data.Functor.Contravariant":"purescript-contravariant","Data.Tuple.Nested":"purescript-tuples","Data.List.Internal":"purescript-lists","Control.Monad":"purescript-prelude","Data.Lazy":"purescript-lazy","Data.Monoid":"purescript-prelude","Data.Profunctor.Closed":"purescript-profunctor","Control.Monad.List.Trans":"purescript-transformers","Data.Ord.Generic":"purescript-prelude","Control.Monad.RWS":"purescript-transformers","Data.String.Common":"purescript-strings","Data.Maybe.First":"purescript-maybe","Control.Bind":"purescript-prelude","Data.Profunctor.Split":"purescript-profunctor","Data.Number.Format":"purescript-numbers","Data.CodePoint.Unicode.Internal.Casing":"purescript-unicode","Data.Monoid.Additive":"purescript-prelude","Data.Symbol":"purescript-prelude","Data.String.Regex":"purescript-strings","Data.Profunctor.Join":"purescript-profunctor","Data.HeytingAlgebra":"purescript-prelude","Control.Alt":"purescript-control","Control.Monad.Maybe.Trans":"purescript-transformers","Control.Monad.Cont":"purescript-transformers","Control.Monad.ST.Internal":"purescript-st","Effect.Ref":"purescript-refs","Data.Either.Inject":"purescript-either","Foreign.Object.ST.Unsafe":"purescript-foreign-object","Data.List.ZipList":"purescript-lists","Data.Ord.Min":"purescript-orders","Data.Functor.Coproduct.Nested":"purescript-functors","Data.Ring.Generic":"purescript-prelude","Data.Semigroup":"purescript-prelude","Data.Array.NonEmpty":"purescript-arrays","Control.Monad.Reader":"purescript-transformers","Data.Const":"purescript-const","Control.Comonad.Traced.Trans":"purescript-transformers","Data.Ord.Down":"purescript-orders","Data.Number.Approximate":"purescript-numbers","Data.Array.ST.Partial":"purescript-arrays","Effect.Unsafe":"purescript-effect","Type.Data.Ordering":"purescript-typelevel-prelude","Data.Tuple":"purescript-tuples","Data.Functor.Clown":"purescript-functors","Data.Semigroup.Foldable":"purescript-foldable-traversable","Control.Biapply":"purescript-bifunctors","Data.Distributive":"purescript-distributive","Effect.Exception":"purescript-exceptions","Type.Equality":"purescript-type-equality","Control.Alternative":"purescript-control","Data.Semiring":"purescript-prelude","Data.Functor.Product2":"purescript-functors","Data.Exists":"purescript-exists","Effect.Console":"purescript-console","Data.CodePoint.Unicode":"purescript-unicode","Data.Traversable.Accum":"purescript-foldable-traversable","Node.Buffer.Class":"purescript-node-buffer","Data.CommutativeRing":"purescript-prelude","Data.NaturalTransformation":"purescript-prelude","Data.Monoid.Conj":"purescript-prelude","Data.Functor.App":"purescript-functors","Data.Profunctor.Star":"purescript-profunctor","Data.Unfoldable":"purescript-unfoldable","Type.RowList":"purescript-typelevel-prelude","Control.Comonad.Store.Trans":"purescript-transformers","Foreign.Object.Unsafe":"purescript-foreign-object","Control.Monad.ST":"purescript-st","Control.Monad.State.Class":"purescript-transformers","Data.List.Types":"purescript-lists","Data.String.NonEmpty.CodeUnits":"purescript-strings","Data.Functor":"purescript-prelude","Unsafe.Coerce":"purescript-unsafe-coerce","Control.Monad.Writer.Class":"purescript-transformers","Data.Profunctor.Strong":"purescript-profunctor","Control.Monad.Except":"purescript-transformers","Data.List.Lazy.Types":"purescript-lists","Control.Category":"purescript-prelude","Control.Monad.Gen.Common":"purescript-gen","Control.Monad.RWS.Trans":"purescript-transformers","Control.Monad.Cont.Trans":"purescript-transformers","Data.Maybe":"purescript-maybe","Type.Row":"purescript-typelevel-prelude","Data.String.Regex.Unsafe":"purescript-strings","Foreign.Object.ST":"purescript-foreign-object","Data.Profunctor":"purescript-profunctor","Control.Comonad":"purescript-control","Control.Monad.ST.Global":"purescript-st","Data.Function":"purescript-prelude","Data.List":"purescript-lists","Data.Field":"purescript-prelude","Data.List.Lazy":"purescript-lists","Data.EuclideanRing":"purescript-prelude","Data.Semigroup.Last":"purescript-prelude","Data.Semigroup.First":"purescript-prelude","Data.Functor.Invariant":"purescript-invariant","Node.Buffer.Internal":"purescript-node-buffer","Control.Comonad.Traced":"purescript-transformers","Data.Comparison":"purescript-contravariant","Data.String.Unsafe":"purescript-strings","Prelude":"purescript-prelude","Effect.Class":"purescript-effect","Data.Predicate":"purescript-contravariant","Partial.Unsafe":"purescript-partial","Data.Array":"purescript-arrays","Control.Extend":"purescript-control","Data.Unfoldable1":"purescript-unfoldable","Control.Lazy":"purescript-control","Data.Function.Uncurried":"purescript-functions","Control.Monad.Reader.Trans":"purescript-transformers","Data.Functor.Product.Nested":"purescript-functors","Control.Comonad.Env.Class":"purescript-transformers","Node.Buffer.Immutable":"purescript-node-buffer","Data.ArrayBuffer.Types":"purescript-arraybuffer-types","Data.Eq":"purescript-prelude","Data.Either.Nested":"purescript-either","Data.Newtype":"purescript-newtype","Data.Semigroup.Traversable":"purescript-foldable-traversable","Data.Bifunctor":"purescript-bifunctors","Test.Assert":"purescript-assert","Data.Monoid.Disj":"purescript-prelude","Control.Monad.Gen.Class":"purescript-gen","Data.Array.Partial":"purescript-arrays","Data.String.CaseInsensitive":"purescript-strings","Node.Stream":"purescript-node-streams","Control.MonadPlus":"purescript-control","Data.Void":"purescript-prelude","Data.Profunctor.Costrong":"purescript-profunctor","Data.Ord.Max":"purescript-orders","Control.Comonad.Store":"purescript-transformers","Node.Process":"purescript-node-process","Control.Monad.Except.Trans":"purescript-transformers","Data.String.CodeUnits":"purescript-strings","Data.FunctorWithIndex":"purescript-foldable-traversable","Data.Divisible":"purescript-contravariant","Data.Eq.Generic":"purescript-prelude","Data.DivisionRing":"purescript-prelude","Data.Equivalence":"purescript-contravariant","Data.Maybe.Last":"purescript-maybe","Data.Unit":"purescript-prelude","Data.List.NonEmpty":"purescript-lists","Data.List.Lazy.NonEmpty":"purescript-lists","Data.Ordering":"purescript-prelude","Data.Functor.Coproduct":"purescript-functors","Control.Monad.Cont.Class":"purescript-transformers","Data.Identity":"purescript-identity","Control.Comonad.Trans.Class":"purescript-transformers","Data.String":"purescript-strings","Data.Reflectable":"purescript-prelude","Control.Plus":"purescript-control","Node.Buffer.Types":"purescript-node-buffer","Data.Posix":"purescript-posix-types","Data.Posix.Signal":"purescript-posix-types","Partial":"purescript-partial","Control.Comonad.Env.Trans":"purescript-transformers","Control.Monad.Reader.Class":"purescript-transformers","Data.String.NonEmpty.CodePoints":"purescript-strings","Data.Decidable":"purescript-contravariant","Data.String.NonEmpty.Internal":"purescript-strings","Data.Monoid.Multiplicative":"purescript-prelude","Data.String.NonEmpty.CaseInsensitive":"purescript-strings","Data.Functor.Joker":"purescript-functors","Type.Data.Symbol":"purescript-typelevel-prelude","Data.Array.ST":"purescript-arrays","Node.Buffer":"purescript-node-buffer","Control.Monad.Error.Class":"purescript-transformers","Control.Semigroupoid":"purescript-prelude","Data.Monoid.Alternate":"purescript-control","Data.Char":"purescript-strings","Data.Generic.Rep":"purescript-prelude","Effect.Class.Console":"purescript-console","Data.Bifunctor.Join":"purescript-bifunctors","Data.Bifoldable":"purescript-foldable-traversable","Control.Monad.ST.Ref":"purescript-st","Data.Monoid.Endo":"purescript-prelude","Control.Monad.State":"purescript-transformers","Data.List.Partial":"purescript-lists","Data.Semiring.Generic":"purescript-prelude","Data.String.Regex.Flags":"purescript-strings","Data.Either":"purescript-either","Type.Prelude":"purescript-typelevel-prelude","Control.Applicative":"purescript-prelude","Control.Monad.ST.Class":"purescript-st","Data.FoldableWithIndex":"purescript-foldable-traversable","Data.Op":"purescript-contravariant","Node.Platform":"purescript-node-process","Record.Unsafe":"purescript-prelude","Control.Monad.Writer":"purescript-transformers","Data.Functor.Coproduct.Inject":"purescript-functors","Data.Profunctor.Choice":"purescript-profunctor","Data.Traversable":"purescript-foldable-traversable","Data.String.Gen":"purescript-strings"},"compilerVersion":"0.14.5"}