{"uploader":"JordanMartinez","packageMeta":{"homepage":"https://github.com/purescript/purescript-safe-coerce","repository":{"url":"https://github.com/purescript/purescript-safe-coerce.git","type":"git"},"ignore":["**/.*","bower_components","node_modules","output","test","bower.json","package.json"],"devDependencies":{"purescript-console":"^6.0.0","purescript-assert":"^6.0.0"},"dependencies":{"purescript-unsafe-coerce":"^6.0.0"},"name":"purescript-safe-coerce","license":["BSD-3-Clause"]},"tagTime":"2022-04-27T14:56:52+0000","modules":[{"reExports":[{"moduleName":{"package":null,"item":["Prim","Coerce"]},"declarations":[{"kind":null,"children":[],"comments":"Coercible is a two-parameter type class that has instances for types `a`\nand `b` if the compiler can infer that they have the same representation.\nCoercible constraints are solved according to the following rules:\n\n* _reflexivity_, any type has the same representation as itself:\n`Coercible a a` holds.\n\n* _symmetry_, if a type `a` can be coerced to some other type `b`, then `b`\ncan also be coerced back to `a`: `Coercible a b` implies `Coercible b a`.\n\n* _transitivity_, if a type `a` can be coerced to some other type `b` which\ncan be coerced to some other type `c`, then `a` can also be coerced to `c`:\n`Coercible a b` and `Coercible b c` imply `Coercible a c`.\n\n* Newtypes can be freely wrapped and unwrapped when their constructor is\nin scope:\n\n      newtype Age = Age Int\n\n`Coercible Int Age` and `Coercible Age Int` hold since `Age` has the same\nruntime representation than `Int`.\n\nNewtype constructors have to be in scope to preserve abstraction. It's\ncommon to declare a newtype to encode some invariants (non emptiness of\narrays with `Data.Array.NonEmpty.NonEmptyArray` for example), hide its\nconstructor and export smart constructors instead. Without this restriction,\nthe guarantees provided by such newtypes would be void.\n\n* If none of the above are applicable, two types of kind `Type` may be\ncoercible, but only if their heads are the same. For example,\n`Coercible (Maybe a) (Either a b)` does not hold because `Maybe` and\n`Either` are different. Those types don't share a common runtime\nrepresentation so coercing between them would be unsafe. In addition their\narguments may need to be identical or coercible, depending on the _roles_\nof the head's type parameters. Roles are documented in [the PureScript\nlanguage reference](https://github.com/purescript/documentation/blob/master/language/Roles.md).\n\nCoercible being polykinded, we can also coerce more than types of kind `Type`:\n\n* Rows are coercible when they have the same labels, when the corresponding\npairs of types are coercible and when their tails are coercible:\n`Coercible ( label :: a | r ) ( label :: b | s )` holds when\n`Coercible a b` and `Coercible r s` do. Closed rows cannot be coerced to\nopen rows.\n\n* Higher kinded types are coercible if they are coercible when fully\nsaturated: `Coercible (f :: _ -> Type) (g :: _ -> Type)` holds when\n`Coercible (f a) (g a)` does.\n\nThis rule may seem puzzling since there is no term of type `_ -> Type` to\napply `coerce` to, but it is necessary when coercing types with higher\nkinded parameters.\n","title":"Coercible","info":{"fundeps":[],"arguments":[["a",{"annotation":[],"tag":"TypeVar","contents":"k"}],["b",{"annotation":[],"tag":"TypeVar","contents":"k"}]],"declType":"typeClass","superclasses":[]},"sourceSpan":null}]}],"name":"Safe.Coerce","comments":null,"declarations":[{"kind":null,"children":[],"comments":"Coerce a value of one type to a value of some other type, without changing\nits runtime representation. This function behaves identically to\n`unsafeCoerce` at runtime. Unlike `unsafeCoerce`, it is safe, because the\n`Coercible` constraint prevents any use of this function from compiling\nunless the compiler can prove that the two types have the same runtime\nrepresentation.\n\nOne application for this function is to avoid doing work that you know is a\nno-op because of newtypes. For example, if you have an `Array (Conj a)` and you\nwant an `Array (Disj a)`, you could do `Data.Array.map (un Conj >>> Disj)`, but\nthis performs an unnecessary traversal of the array, with O(n) cost.\n`coerce` accomplishes the same with only O(1) cost:\n\n```purescript\nmapConjToDisj :: forall a. Array (Conj a) -> Array (Disj a)\nmapConjToDisj = coerce\n```\n","title":"coerce","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Prim","Coerce"],"Coercible"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"},{"annotation":[],"tag":"TypeVar","contents":"b"}],"constraintKindArgs":[],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},null]},null]}},"sourceSpan":{"start":[26,1],"name":"/home/jordan/Programming/ps-libs/lib/safe-coerce/src/Safe/Coerce.purs","end":[26,46]}}]}],"resolvedDependencies":{"purescript-effect":"4.0.0","purescript-console":"6.0.0","purescript-prelude":"6.0.0","purescript-assert":"6.0.0","purescript-unsafe-coerce":"6.0.0"},"version":"2.0.0","github":["purescript","purescript-safe-coerce"],"versionTag":"v2.0.0","moduleMap":{"Data.BooleanAlgebra":"purescript-prelude","Data.Ring":"purescript-prelude","Data.Semigroup.Generic":"purescript-prelude","Effect.Uncurried":"purescript-effect","Data.Monoid.Generic":"purescript-prelude","Effect":"purescript-effect","Data.HeytingAlgebra.Generic":"purescript-prelude","Data.Ord":"purescript-prelude","Data.Bounded.Generic":"purescript-prelude","Data.Monoid.Dual":"purescript-prelude","Data.Boolean":"purescript-prelude","Data.Show.Generic":"purescript-prelude","Type.Proxy":"purescript-prelude","Data.Bounded":"purescript-prelude","Data.Show":"purescript-prelude","Control.Apply":"purescript-prelude","Control.Monad":"purescript-prelude","Data.Monoid":"purescript-prelude","Data.Ord.Generic":"purescript-prelude","Control.Bind":"purescript-prelude","Data.Monoid.Additive":"purescript-prelude","Data.Symbol":"purescript-prelude","Data.HeytingAlgebra":"purescript-prelude","Data.Ring.Generic":"purescript-prelude","Data.Semigroup":"purescript-prelude","Effect.Unsafe":"purescript-effect","Data.Semiring":"purescript-prelude","Effect.Console":"purescript-console","Data.CommutativeRing":"purescript-prelude","Data.NaturalTransformation":"purescript-prelude","Data.Monoid.Conj":"purescript-prelude","Data.Functor":"purescript-prelude","Unsafe.Coerce":"purescript-unsafe-coerce","Control.Category":"purescript-prelude","Data.Function":"purescript-prelude","Data.Field":"purescript-prelude","Data.EuclideanRing":"purescript-prelude","Data.Semigroup.Last":"purescript-prelude","Data.Semigroup.First":"purescript-prelude","Prelude":"purescript-prelude","Effect.Class":"purescript-effect","Data.Eq":"purescript-prelude","Test.Assert":"purescript-assert","Data.Monoid.Disj":"purescript-prelude","Data.Void":"purescript-prelude","Data.Eq.Generic":"purescript-prelude","Data.DivisionRing":"purescript-prelude","Data.Unit":"purescript-prelude","Data.Ordering":"purescript-prelude","Data.Reflectable":"purescript-prelude","Data.Monoid.Multiplicative":"purescript-prelude","Control.Semigroupoid":"purescript-prelude","Data.Generic.Rep":"purescript-prelude","Effect.Class.Console":"purescript-console","Data.Monoid.Endo":"purescript-prelude","Data.Semiring.Generic":"purescript-prelude","Control.Applicative":"purescript-prelude","Record.Unsafe":"purescript-prelude"},"compilerVersion":"0.14.5"}