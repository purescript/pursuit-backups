{"uploader":"thomashoneyman","packageMeta":{"homepage":"https://github.com/purescript/purescript-safe-coerce","repository":{"url":"https://github.com/purescript/purescript-safe-coerce.git","type":"git"},"ignore":["**/.*","bower_components","node_modules","output","test","bower.json","package.json"],"devDependencies":{"purescript-console":"^5.0.0","purescript-assert":"^5.0.0"},"dependencies":{"purescript-unsafe-coerce":"^5.0.0"},"name":"purescript-safe-coerce","license":["BSD-3-Clause"]},"tagTime":"2021-02-26T17:15:34+0000","modules":[{"reExports":[{"moduleName":{"package":null,"item":["Prim","Coerce"]},"declarations":[{"children":[],"comments":"Coercible is a two-parameter type class that has instances for types `a`\nand `b` if the compiler can infer that they have the same representation.\nThis class does not have regular instances; instead they are created\non-the-fly during type-checking according to a set of rules.\n\nFirst, Coercible obeys reflexivity - any type has the same representation\nas itself:\n\n    instance coercibleReflexive :: Coercible a a\n\nSecond, Coercible obeys symmetry - if a type `a` can be coerced to some\nother type `b`, then `b` can also be coerced back to `a`:\n\n    instance coercibleSymmetric :: Coercible a b => Coercible b a\n\nThird, Coercible obeys transitivity - if a type `a` can be coerced to some\nother type `b` which can be coerced to some other type `c`, then `a` can\nalso be coerced to `c`:\n\n    instance coercibleTransitive :: (Coercible a b, Coercible b c) => Coercible a c\n\nFourth, for every type constructor there is an instance that allows one\nto coerce under the type constructor (`data` or `newtype`). For example,\ngiven a definition:\n\ndata D a b = D a\n\nthere is an instance:\n\n    instance coercibleConstructor :: Coercible a a' => Coercible (D a b) (D a' b')\n\nNote that, since the type variable `a` plays a role in `D`'s representation,\nwe require that the types `a` and `a'` are themselves `Coercible`. However,\nsince the variable `b` does not play a part in `D`'s representation (a type\nsuch as `b` is thus typically referred to as a \"phantom\" type), `b` and `b'`\ncan differ arbitrarily.\n\nFifth, for every `newtype NT = MkNT T`, there is a pair of instances which\npermit coercion in and out of the `newtype`:\n\n    instance coercibleNewtypeLeft  :: Coercible a T => Coercible a NT\n    instance coercibleNewtypeRight :: Coercible T b => Coercible NT b\n\nTo prevent breaking abstractions, these instances are only usable if the\nconstructor `MkNT` is in scope.\n\nSixth, every pair of unsaturated type constructors can be coerced if\nthere is an instance for the fully saturated types. For example,\ngiven the definitions:\n\nnewtype NT1 a = MkNT1 a\nnewtype NT2 a b = MkNT2 b\n\nthere is an instance:\n\n    instance coercibleUnsaturedTypes :: Coercible (NT1 b) (NT2 a b) => Coercible NT1 (NT2 a)\n\nThis rule may seem puzzling since it is impossible to apply `coerce` to a term\nof type `NT1` but it is necessary to coerce types with higher kinded parameters.\n\nSeventh, every pair of rows can be coerced if they have the same labels,\nthe corresponding types for each label and their tails are coercible:\n\n    instance coercibleRow :: (Coercible a b, Coercible r s) => Coercible ( label :: a | r ) ( label :: b | s )\n\nClosed rows can't be coerced to open rows.\n","title":"Coercible","info":{"fundeps":[],"arguments":[["a",{"annotation":[],"tag":"TypeVar","contents":"k"}],["b",{"annotation":[],"tag":"TypeVar","contents":"k"}]],"declType":"typeClass","superclasses":[]},"sourceSpan":null}]}],"name":"Safe.Coerce","comments":null,"declarations":[{"children":[],"comments":"Coerce a value of one type to a value of some other type, without changing\nits runtime representation. This function behaves identically to\n`unsafeCoerce` at runtime. Unlike `unsafeCoerce`, it is safe, because the\n`Coercible` constraint prevents any use of this function from compiling\nunless the compiler can prove that the two types have the same runtime\nrepresentation.\n\nOne application for this function is to avoid doing work that you know is a\nno-op because of newtypes. For example, if you have an `Array (Conj a)` and you\nwant an `Array (Disj a)`, you could do `Data.Array.map (un Conj >>> Disj)`, but\nthis performs an unnecessary traversal of the array, with O(n) cost.\n`coerce` accomplishes the same with only O(1) cost:\n\n```purescript\nmapConjToDisj :: forall a. Array (Conj a) -> Array (Disj a)\nmapConjToDisj = coerce\n```\n","title":"coerce","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Prim","Coerce"],"Coercible"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"},{"annotation":[],"tag":"TypeVar","contents":"b"}],"constraintKindArgs":[],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},null]},null]}},"sourceSpan":{"start":[26,1],"name":"/Users/trh/Desktop/release/purescript-safe-coerce/src/Safe/Coerce.purs","end":[26,46]}}]}],"resolvedDependencies":{"purescript-effect":"3.0.0","purescript-console":"5.0.0","purescript-prelude":"5.0.0","purescript-assert":"5.0.0","purescript-unsafe-coerce":"5.0.0"},"version":"1.0.0","github":["purescript","purescript-safe-coerce"],"versionTag":"v1.0.0","moduleMap":{"Data.BooleanAlgebra":"purescript-prelude","Data.Ring":"purescript-prelude","Data.Semigroup.Generic":"purescript-prelude","Effect.Uncurried":"purescript-effect","Data.Monoid.Generic":"purescript-prelude","Effect":"purescript-effect","Data.HeytingAlgebra.Generic":"purescript-prelude","Data.Ord":"purescript-prelude","Data.Bounded.Generic":"purescript-prelude","Type.Data.Row":"purescript-prelude","Data.Monoid.Dual":"purescript-prelude","Data.Boolean":"purescript-prelude","Data.Show.Generic":"purescript-prelude","Type.Proxy":"purescript-prelude","Data.Bounded":"purescript-prelude","Data.Show":"purescript-prelude","Control.Apply":"purescript-prelude","Control.Monad":"purescript-prelude","Data.Monoid":"purescript-prelude","Data.Ord.Generic":"purescript-prelude","Control.Bind":"purescript-prelude","Data.Monoid.Additive":"purescript-prelude","Data.Symbol":"purescript-prelude","Data.HeytingAlgebra":"purescript-prelude","Type.Data.RowList":"purescript-prelude","Data.Ring.Generic":"purescript-prelude","Data.Semigroup":"purescript-prelude","Effect.Unsafe":"purescript-effect","Data.Semiring":"purescript-prelude","Effect.Console":"purescript-console","Data.CommutativeRing":"purescript-prelude","Data.NaturalTransformation":"purescript-prelude","Data.Monoid.Conj":"purescript-prelude","Data.Functor":"purescript-prelude","Unsafe.Coerce":"purescript-unsafe-coerce","Control.Category":"purescript-prelude","Data.Function":"purescript-prelude","Data.Field":"purescript-prelude","Data.EuclideanRing":"purescript-prelude","Data.Semigroup.Last":"purescript-prelude","Data.Semigroup.First":"purescript-prelude","Prelude":"purescript-prelude","Effect.Class":"purescript-effect","Data.Eq":"purescript-prelude","Test.Assert":"purescript-assert","Data.Monoid.Disj":"purescript-prelude","Data.Void":"purescript-prelude","Data.Eq.Generic":"purescript-prelude","Data.DivisionRing":"purescript-prelude","Data.Unit":"purescript-prelude","Data.Ordering":"purescript-prelude","Data.Monoid.Multiplicative":"purescript-prelude","Control.Semigroupoid":"purescript-prelude","Data.Generic.Rep":"purescript-prelude","Effect.Class.Console":"purescript-console","Data.Monoid.Endo":"purescript-prelude","Data.Semiring.Generic":"purescript-prelude","Control.Applicative":"purescript-prelude","Record.Unsafe":"purescript-prelude"},"compilerVersion":"0.14.0"}