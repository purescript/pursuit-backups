{"compilerVersion":"0.15.10","github":["UnrelatedString","purescript-trivial-unfold"],"moduleMap":{"Control.Alt":"purescript-control","Control.Alternative":"purescript-control","Control.Applicative":"purescript-prelude","Control.Apply":"purescript-prelude","Control.Biapplicative":"purescript-bifunctors","Control.Biapply":"purescript-bifunctors","Control.Bind":"purescript-prelude","Control.Category":"purescript-prelude","Control.Comonad":"purescript-control","Control.Comonad.Env":"purescript-transformers","Control.Comonad.Env.Class":"purescript-transformers","Control.Comonad.Env.Trans":"purescript-transformers","Control.Comonad.Store":"purescript-transformers","Control.Comonad.Store.Class":"purescript-transformers","Control.Comonad.Store.Trans":"purescript-transformers","Control.Comonad.Traced":"purescript-transformers","Control.Comonad.Traced.Class":"purescript-transformers","Control.Comonad.Traced.Trans":"purescript-transformers","Control.Comonad.Trans.Class":"purescript-transformers","Control.Extend":"purescript-control","Control.Lazy":"purescript-control","Control.Monad":"purescript-prelude","Control.Monad.Cont":"purescript-transformers","Control.Monad.Cont.Class":"purescript-transformers","Control.Monad.Cont.Trans":"purescript-transformers","Control.Monad.Error.Class":"purescript-transformers","Control.Monad.Except":"purescript-transformers","Control.Monad.Except.Trans":"purescript-transformers","Control.Monad.Gen":"purescript-gen","Control.Monad.Gen.Class":"purescript-gen","Control.Monad.Gen.Common":"purescript-gen","Control.Monad.Identity.Trans":"purescript-transformers","Control.Monad.List.Trans":"purescript-transformers","Control.Monad.Maybe.Trans":"purescript-transformers","Control.Monad.RWS":"purescript-transformers","Control.Monad.RWS.Trans":"purescript-transformers","Control.Monad.Reader":"purescript-transformers","Control.Monad.Reader.Class":"purescript-transformers","Control.Monad.Reader.Trans":"purescript-transformers","Control.Monad.Rec.Class":"purescript-tailrec","Control.Monad.ST":"purescript-st","Control.Monad.ST.Class":"purescript-st","Control.Monad.ST.Global":"purescript-st","Control.Monad.ST.Internal":"purescript-st","Control.Monad.ST.Ref":"purescript-st","Control.Monad.ST.Uncurried":"purescript-st","Control.Monad.State":"purescript-transformers","Control.Monad.State.Class":"purescript-transformers","Control.Monad.State.Trans":"purescript-transformers","Control.Monad.Trans.Class":"purescript-transformers","Control.Monad.Writer":"purescript-transformers","Control.Monad.Writer.Class":"purescript-transformers","Control.Monad.Writer.Trans":"purescript-transformers","Control.MonadPlus":"purescript-control","Control.Plus":"purescript-control","Control.Semigroupoid":"purescript-prelude","Data.Array":"purescript-arrays","Data.Array.NonEmpty":"purescript-arrays","Data.Array.NonEmpty.Internal":"purescript-arrays","Data.Array.Partial":"purescript-arrays","Data.Array.ST":"purescript-arrays","Data.Array.ST.Iterator":"purescript-arrays","Data.Array.ST.Partial":"purescript-arrays","Data.Bifoldable":"purescript-foldable-traversable","Data.Bifunctor":"purescript-bifunctors","Data.Bifunctor.Join":"purescript-bifunctors","Data.Bitraversable":"purescript-foldable-traversable","Data.Boolean":"purescript-prelude","Data.BooleanAlgebra":"purescript-prelude","Data.Bounded":"purescript-prelude","Data.Bounded.Generic":"purescript-prelude","Data.Char":"purescript-strings","Data.Char.Gen":"purescript-strings","Data.CommutativeRing":"purescript-prelude","Data.Comparison":"purescript-contravariant","Data.Const":"purescript-const","Data.Decidable":"purescript-contravariant","Data.Decide":"purescript-contravariant","Data.Distributive":"purescript-distributive","Data.Divide":"purescript-contravariant","Data.Divisible":"purescript-contravariant","Data.DivisionRing":"purescript-prelude","Data.Either":"purescript-either","Data.Either.Inject":"purescript-either","Data.Either.Nested":"purescript-either","Data.Enum":"purescript-enums","Data.Enum.Gen":"purescript-enums","Data.Enum.Generic":"purescript-enums","Data.Eq":"purescript-prelude","Data.Eq.Generic":"purescript-prelude","Data.Equivalence":"purescript-contravariant","Data.EuclideanRing":"purescript-prelude","Data.Exists":"purescript-exists","Data.Field":"purescript-prelude","Data.Foldable":"purescript-foldable-traversable","Data.FoldableWithIndex":"purescript-foldable-traversable","Data.Function":"purescript-prelude","Data.Function.Uncurried":"purescript-functions","Data.Functor":"purescript-prelude","Data.Functor.App":"purescript-functors","Data.Functor.Clown":"purescript-functors","Data.Functor.Compose":"purescript-functors","Data.Functor.Contravariant":"purescript-contravariant","Data.Functor.Coproduct":"purescript-functors","Data.Functor.Coproduct.Inject":"purescript-functors","Data.Functor.Coproduct.Nested":"purescript-functors","Data.Functor.Costar":"purescript-functors","Data.Functor.Flip":"purescript-functors","Data.Functor.Invariant":"purescript-invariant","Data.Functor.Joker":"purescript-functors","Data.Functor.Product":"purescript-functors","Data.Functor.Product.Nested":"purescript-functors","Data.Functor.Product2":"purescript-functors","Data.FunctorWithIndex":"purescript-foldable-traversable","Data.Generic.Rep":"purescript-prelude","Data.HeytingAlgebra":"purescript-prelude","Data.HeytingAlgebra.Generic":"purescript-prelude","Data.Identity":"purescript-identity","Data.Int":"purescript-integers","Data.Int.Bits":"purescript-integers","Data.Lazy":"purescript-lazy","Data.List":"purescript-lists","Data.List.Internal":"purescript-lists","Data.List.Lazy":"purescript-lists","Data.List.Lazy.NonEmpty":"purescript-lists","Data.List.Lazy.Types":"purescript-lists","Data.List.NonEmpty":"purescript-lists","Data.List.Partial":"purescript-lists","Data.List.Types":"purescript-lists","Data.List.ZipList":"purescript-lists","Data.Maybe":"purescript-maybe","Data.Maybe.First":"purescript-maybe","Data.Maybe.Last":"purescript-maybe","Data.Monoid":"purescript-prelude","Data.Monoid.Additive":"purescript-prelude","Data.Monoid.Alternate":"purescript-control","Data.Monoid.Conj":"purescript-prelude","Data.Monoid.Disj":"purescript-prelude","Data.Monoid.Dual":"purescript-prelude","Data.Monoid.Endo":"purescript-prelude","Data.Monoid.Generic":"purescript-prelude","Data.Monoid.Multiplicative":"purescript-prelude","Data.NaturalTransformation":"purescript-prelude","Data.Newtype":"purescript-newtype","Data.NonEmpty":"purescript-nonempty","Data.Number":"purescript-numbers","Data.Number.Approximate":"purescript-numbers","Data.Number.Format":"purescript-numbers","Data.Op":"purescript-contravariant","Data.Ord":"purescript-prelude","Data.Ord.Down":"purescript-orders","Data.Ord.Generic":"purescript-prelude","Data.Ord.Max":"purescript-orders","Data.Ord.Min":"purescript-orders","Data.Ordering":"purescript-prelude","Data.Predicate":"purescript-contravariant","Data.Profunctor":"purescript-profunctor","Data.Profunctor.Choice":"purescript-profunctor","Data.Profunctor.Closed":"purescript-profunctor","Data.Profunctor.Cochoice":"purescript-profunctor","Data.Profunctor.Costrong":"purescript-profunctor","Data.Profunctor.Join":"purescript-profunctor","Data.Profunctor.Split":"purescript-profunctor","Data.Profunctor.Star":"purescript-profunctor","Data.Profunctor.Strong":"purescript-profunctor","Data.Reflectable":"purescript-prelude","Data.Ring":"purescript-prelude","Data.Ring.Generic":"purescript-prelude","Data.Semigroup":"purescript-prelude","Data.Semigroup.First":"purescript-prelude","Data.Semigroup.Foldable":"purescript-foldable-traversable","Data.Semigroup.Generic":"purescript-prelude","Data.Semigroup.Last":"purescript-prelude","Data.Semigroup.Traversable":"purescript-foldable-traversable","Data.Semiring":"purescript-prelude","Data.Semiring.Generic":"purescript-prelude","Data.Show":"purescript-prelude","Data.Show.Generic":"purescript-prelude","Data.String":"purescript-strings","Data.String.CaseInsensitive":"purescript-strings","Data.String.CodePoints":"purescript-strings","Data.String.CodeUnits":"purescript-strings","Data.String.Common":"purescript-strings","Data.String.Gen":"purescript-strings","Data.String.NonEmpty":"purescript-strings","Data.String.NonEmpty.CaseInsensitive":"purescript-strings","Data.String.NonEmpty.CodePoints":"purescript-strings","Data.String.NonEmpty.CodeUnits":"purescript-strings","Data.String.NonEmpty.Internal":"purescript-strings","Data.String.Pattern":"purescript-strings","Data.String.Regex":"purescript-strings","Data.String.Regex.Flags":"purescript-strings","Data.String.Regex.Unsafe":"purescript-strings","Data.String.Unsafe":"purescript-strings","Data.Symbol":"purescript-prelude","Data.Traversable":"purescript-foldable-traversable","Data.Traversable.Accum":"purescript-foldable-traversable","Data.Traversable.Accum.Internal":"purescript-foldable-traversable","Data.TraversableWithIndex":"purescript-foldable-traversable","Data.Tuple":"purescript-tuples","Data.Tuple.Nested":"purescript-tuples","Data.Unfoldable":"purescript-unfoldable","Data.Unfoldable1":"purescript-unfoldable","Data.Unit":"purescript-prelude","Data.Void":"purescript-prelude","Effect":"purescript-effect","Effect.Class":"purescript-effect","Effect.Class.Console":"purescript-console","Effect.Console":"purescript-console","Effect.Exception":"purescript-exceptions","Effect.Exception.Unsafe":"purescript-exceptions","Effect.Random":"purescript-random","Effect.Ref":"purescript-refs","Effect.Uncurried":"purescript-effect","Effect.Unsafe":"purescript-effect","Partial":"purescript-partial","Partial.Unsafe":"purescript-partial","Prelude":"purescript-prelude","Random.LCG":"purescript-lcg","Record":"purescript-record","Record.Builder":"purescript-record","Record.Unsafe":"purescript-prelude","Record.Unsafe.Union":"purescript-record","Safe.Coerce":"purescript-safe-coerce","Test.QuickCheck":"purescript-quickcheck","Test.QuickCheck.Arbitrary":"purescript-quickcheck","Test.QuickCheck.Gen":"purescript-quickcheck","Type.Equality":"purescript-type-equality","Type.Proxy":"purescript-prelude","Unsafe.Coerce":"purescript-unsafe-coerce"},"modules":[{"comments":"This \"module\" provides various adapters and other such utilities\nfor `Unfoldable1` and `Unfoldable`.\n","declarations":[{"children":[],"comments":"Returns the first element, if present.\n\nNot particularly useful, because this is just the `Unfoldable`\ninstance for `Maybe`. Included by analogy with `head1`.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable","Trivial","Internal"],"Trivial"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Maybe"],"Maybe"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[69,39],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable/Trivial.purs","start":[69,1]},"title":"head"},{"children":[],"comments":"Removes the first element, if present.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"u","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"u","tag":"TypeVar"}],"constraintClass":[["Data","Unfoldable"],"Unfoldable"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable","Trivial","Internal"],"Trivial"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":"u","tag":"TypeVar"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[73,53],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable/Trivial.purs","start":[73,1]},"title":"tail"},{"children":[],"comments":"Keep only a number of elements from the start.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"u","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"u","tag":"TypeVar"}],"constraintClass":[["Data","Unfoldable"],"Unfoldable"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"Int"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable","Trivial","Internal"],"Trivial"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":"u","tag":"TypeVar"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[87,60],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable/Trivial.purs","start":[87,1]},"title":"take"},{"children":[],"comments":"Prepend an element.\n\nDo not use this to create a data structure. Please use Data.List.Lazy instead.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"u","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"u","tag":"TypeVar"}],"constraintClass":[["Data","Unfoldable1"],"Unfoldable1"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable","Trivial","Internal"],"Trivial"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":"u","tag":"TypeVar"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[131,59],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable/Trivial.purs","start":[131,1]},"title":"cons"},{"children":[],"comments":"Append an element.\n\nDo not use this to create a data structure. Please use Data.List.Lazy instead.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"u","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"u","tag":"TypeVar"}],"constraintClass":[["Data","Unfoldable1"],"Unfoldable1"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable","Trivial","Internal"],"Trivial"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":"u","tag":"TypeVar"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[141,59],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable/Trivial.purs","start":[141,1]},"title":"snoc"},{"children":[],"comments":"Returns the first element and a new `Unfoldable` generating the remaining elements,\nor `Nothing` if there are no elements.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"u","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"u","tag":"TypeVar"}],"constraintClass":[["Data","Unfoldable"],"Unfoldable"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable","Trivial","Internal"],"Trivial"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Maybe"],"Maybe"],"tag":"TypeConstructor"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Tuple","Nested"],"/\\"],"tag":"TypeOp"},{"annotation":[],"contents":"a","tag":"TypeVar"},{"annotation":[],"contents":[{"annotation":[],"contents":"u","tag":"TypeVar"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"BinaryNoParensType"},"tag":"ParensInType"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[58,68],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable/Trivial.purs","start":[58,1]},"title":"uncons"},{"children":[],"comments":"Get the element at the specified 0-index, or `Nothing` if the index is out-of-bounds.\n\nTime complexity: `O(n)` in the index (calls to the generating function).\n(Does not terminate early if it goes past the end!)\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable","Trivial","Internal"],"Trivial"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"Int"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Maybe"],"Maybe"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"TypeApp"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[80,47],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable/Trivial.purs","start":[80,1]},"title":"index"},{"children":[],"comments":"Drop a number of elements from the start.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"u","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"u","tag":"TypeVar"}],"constraintClass":[["Data","Unfoldable"],"Unfoldable"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"Int"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable","Trivial","Internal"],"Trivial"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":"u","tag":"TypeVar"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[99,60],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable/Trivial.purs","start":[99,1]},"title":"drop"},{"children":[],"comments":"`foldl` specialized to `Trivial`. \"Re-fold\" a polymorphic `Unfoldable`.\nUsually cleaner and more convenient than `turbofish`, when applicable.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"c","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"c","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":"c","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},"tag":"ParensInType"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"c","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable","Trivial","Internal"],"Trivial"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":"c","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"TypeApp"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[110,60],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable/Trivial.purs","start":[110,1]},"title":"refoldl"},{"children":[],"comments":"`foldr` specialized to `Trivial`. \"Re-fold\" a polymorphic `Unfoldable`.\nUsually cleaner and more convenient than `turbofish`, when applicable.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"c","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"c","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":"c","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},"tag":"ParensInType"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"c","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable","Trivial","Internal"],"Trivial"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":"c","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"TypeApp"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[115,60],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable/Trivial.purs","start":[115,1]},"title":"refoldr"},{"children":[],"comments":"`foldMap` specialized to `Trivial`. \"Re-fold\" a polymorphic `Unfoldable`.\nUsually cleaner and more convenient than `turbofish`, when applicable.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"c","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"c","tag":"TypeVar"}],"constraintClass":[["Data","Monoid"],"Monoid"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":"c","tag":"TypeVar"}],"tag":"TypeApp"},"tag":"ParensInType"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable","Trivial","Internal"],"Trivial"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":"c","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[120,64],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable/Trivial.purs","start":[120,1]},"title":"refoldMap"},{"children":[],"comments":"`fold` specialized to `Trivial`. \"Re-fold\" a polymorphic `Unfoldable`.\nUsually cleaner and more convenient than `turbofish`, when applicable.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"a","tag":"TypeVar"}],"constraintClass":[["Data","Monoid"],"Monoid"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable","Trivial","Internal"],"Trivial"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[125,47],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable/Trivial.purs","start":[125,1]},"title":"refold"}],"name":"Data.Unfoldable.Trivial","reExports":[{"declarations":[{"children":[],"comments":"Provides a default implementation of `unfoldr1` using `unfoldr` to satisfy\nthe superclass bound on `Unfoldable`.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"b","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"t","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"t","tag":"TypeVar"}],"constraintClass":[["Data","Unfoldable"],"Unfoldable"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"b","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Tuple","Nested"],"/\\"],"tag":"TypeOp"},{"annotation":[],"contents":"a","tag":"TypeVar"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Maybe"],"Maybe"],"tag":"TypeConstructor"},{"annotation":[],"contents":"b","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"BinaryNoParensType"}],"tag":"TypeApp"},"tag":"ParensInType"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"b","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":"t","tag":"TypeVar"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[83,81],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable/Trivial/Internal.purs","start":[83,1]},"title":"unfoldr1Default"},{"children":[],"comments":"Function application specialized to a `Trivial` argument,\nat the same precedence as `($)`.\n\nInspired by the Rust syntax of the same name, often used in the\nanalogous context of collecting from an iterator.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"b","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable","Trivial","Internal"],"Trivial"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":"b","tag":"TypeVar"}],"tag":"TypeApp"},"tag":"ParensInType"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable","Trivial","Internal"],"Trivial"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":"b","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[54,60],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable/Trivial/Internal.purs","start":[54,1]},"title":"turbofish"},{"children":[],"comments":"Specializes its argument to `Trivial`.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable","Trivial","Internal"],"Trivial"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable","Trivial","Internal"],"Trivial"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[46,44],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable/Trivial/Internal.purs","start":[46,1]},"title":"trivial"},{"children":[],"comments":null,"info":{"alias":[["Data","Unfoldable","Trivial","Internal"],{"Right":{"Left":{"Ident":"turbofish"}}}],"declType":"alias","fixity":{"associativity":"infixr","precedence":0}},"kind":null,"sourceSpan":{"end":[57,28],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable/Trivial/Internal.purs","start":[57,1]},"title":"(::<*>)"}],"moduleName":{"item":["Data","Unfoldable","Trivial","Internal"],"package":null}},{"declarations":[{"children":[{"comments":"Wraps both arguments to `unfoldr1` in an `Unfoldr1Call`.\n","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1"],"Unfoldable1"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"}],"tag":"TypeApp"}},"sourceSpan":{"end":[70,62],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1/Internal.purs","start":[69,1]},"title":"trivial1Unfoldable1"},{"comments":null,"info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Functor"],"Functor"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"}],"tag":"TypeApp"}},"sourceSpan":{"end":[80,31],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1/Internal.purs","start":[72,1]},"title":"trivial1Functor"},{"comments":null,"info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Foldable"],"Foldable"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"}],"tag":"TypeApp"}},"sourceSpan":{"end":[109,32],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1/Internal.purs","start":[98,1]},"title":"trivial1Foldable"},{"comments":"The *raison d'Ãªtre* for `Trivial1`.\nAllows folding polymorphic `Unfoldable1`s as they generate\nwith no explicit starting value. In particular, `foldMap1`\nneeds map only into a `Semigroup` rather than a `Monoid`.\n\n`foldr1` uses a default implementation and may be inefficient.\n","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Semigroup","Foldable"],"Foldable1"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"}],"tag":"TypeApp"}},"sourceSpan":{"end":[124,34],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1/Internal.purs","start":[117,1]},"title":"trivial1Foldable1"},{"comments":"Guaranteed finite.\n","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"a","tag":"TypeVar"}],"constraintClass":[["Test","QuickCheck","Arbitrary"],"Arbitrary"],"constraintData":null,"constraintKindArgs":[]},{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"a","tag":"TypeVar"}],"constraintClass":[["Test","QuickCheck","Arbitrary"],"Coarbitrary"],"constraintData":null,"constraintKindArgs":[]}],"type":{"annotation":[],"contents":[{"annotation":[],"contents":[["Test","QuickCheck","Arbitrary"],"Arbitrary"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"}},"sourceSpan":{"end":[136,18],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1/Internal.purs","start":[127,1]},"title":"trivialArbitrary"}],"comments":"A type wrapping `unfoldr1` calls, existentially quantified over the seed type\nso that it can be ignored in the type constructor. Its `Unfoldable1` instance\nmeans that it can directly be constructed by calling `unfoldr1`.\n","info":{"dataDeclType":"newtype","declType":"data","roles":["Representational"],"typeArguments":[["a",null]]},"kind":null,"sourceSpan":{"end":[47,56],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1/Internal.purs","start":[47,1]},"title":"Trivial1"},{"children":[],"comments":"Unfold an infinite `Unfoldable1`.\nAnalogous to `unfold1` and `unfold`, but with no way to signal termination;\n`unfoldInf f b` consists of `fst $ f b` appended to `unfoldInf f $ snd $ f b`.\n\nThis should only be used to produce either lazy types (like `Trivial`) or\ntypes with truncating `Unfoldable1` instances (like `Maybe`).\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"b","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"u","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"u","tag":"TypeVar"}],"constraintClass":[["Data","Unfoldable1"],"Unfoldable1"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"b","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Tuple","Nested"],"/\\"],"tag":"TypeOp"},{"annotation":[],"contents":"a","tag":"TypeVar"},{"annotation":[],"contents":"b","tag":"TypeVar"}],"tag":"BinaryNoParensType"}],"tag":"TypeApp"},"tag":"ParensInType"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"b","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":"u","tag":"TypeVar"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[117,71],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1.purs","start":[117,1]},"title":"unfoldrInf"},{"children":[],"comments":"Returns the first element, and an `Unfoldable` of the remaining elements.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"u","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"u","tag":"TypeVar"}],"constraintClass":[["Data","Unfoldable"],"Unfoldable"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Tuple","Nested"],"/\\"],"tag":"TypeOp"},{"annotation":[],"contents":"a","tag":"TypeVar"},{"annotation":[],"contents":[{"annotation":[],"contents":"u","tag":"TypeVar"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"BinaryNoParensType"}],"tag":"TypeApp"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[93,62],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1/Internal.purs","start":[93,1]},"title":"uncons1"},{"children":[],"comments":"Function application specialized to a `Trivial1` argument,\nat the same precedence as `($)`.\n\nInspired by the Rust syntax of the same name, often used in the\nanalogous context of collecting from an iterator.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"b","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":"b","tag":"TypeVar"}],"tag":"TypeApp"},"tag":"ParensInType"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":"b","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[58,63],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1/Internal.purs","start":[58,1]},"title":"turbofish1"},{"children":[],"comments":"Specializes its argument to `Trivial1`.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[50,47],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1/Internal.purs","start":[50,1]},"title":"trivial1"},{"children":[],"comments":"Keep only a strictly positive number of elements from the start.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"u","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"u","tag":"TypeVar"}],"constraintClass":[["Data","Unfoldable1"],"Unfoldable1"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"Int"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":"u","tag":"TypeVar"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[55,63],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1.purs","start":[55,1]},"title":"take1"},{"children":[],"comments":"Removes the first element.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"u","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"u","tag":"TypeVar"}],"constraintClass":[["Data","Unfoldable"],"Unfoldable"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":"u","tag":"TypeVar"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[51,55],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1.purs","start":[51,1]},"title":"tail1"},{"children":[],"comments":"`foldr1` specialized to `Trivial1`. \"Re-fold\" a polymorphic `Unfoldable1`.\nUsually cleaner and more convenient than `turbofish`, when applicable.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},"tag":"ParensInType"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[93,55],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1.purs","start":[93,1]},"title":"refoldr1"},{"children":[],"comments":"`foldl1` specialized to `Trivial1`. \"Re-fold\" a polymorphic `Unfoldable1`.\nUsually cleaner and more convenient than `turbofish`, when applicable.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},"tag":"ParensInType"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[88,55],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1.purs","start":[88,1]},"title":"refoldl1"},{"children":[],"comments":"`foldMap` specialized to `Trivial1`. \"Re-fold\" a polymorphic `Unfoldable1`.\nUsually cleaner and more convenient than `turbofish1`, when applicable.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"c","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"c","tag":"TypeVar"}],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":"c","tag":"TypeVar"}],"tag":"TypeApp"},"tag":"ParensInType"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":"c","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[98,69],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1.purs","start":[98,1]},"title":"refoldMap1"},{"children":[],"comments":"`fold` specialized to `Trivial1`. \"Re-fold\" a polymorphic `Unfoldable1`.\nUsually cleaner and more convenient than `turbofish1`, when applicable.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"a","tag":"TypeVar"}],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[103,52],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1.purs","start":[103,1]},"title":"refold1"},{"children":[],"comments":"Create an infinite `Unfoldable1` by repeated application of a function to a seed value. \nAnalogous to `iterateN`, but with no iteration limit.\n\nThis should only be used to produce either lazy types (like `Trivial`) or\ntypes with truncating `Unfoldable1` instances (like `Maybe`).\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"u","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"u","tag":"TypeVar"}],"constraintClass":[["Data","Unfoldable1"],"Unfoldable1"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"},"tag":"ParensInType"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":"u","tag":"TypeVar"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[125,61],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1.purs","start":[125,1]},"title":"iterate"},{"children":[],"comments":"Get the element at the specified *modular* 0-index, i.e. the element\nat that 0-index in the elements infinitely extended left and right.\n\nWill loop infinitely if given an infinite `Unfoldable1` and a negative index.\nWill not loop infinitely if given an infinite `Unfoldable1` and a nonnegative index;\ncomputes the length for itself as it iterates. Iterates twice when resolving an out of\nbounds index; does not store any intermediate results. In general, this function is\nnot supposed to be *used for modular indexing*, because modular indexing just happens\nto be a simple and sensible way to guarantee an output, and there's no point in this\nexisting without a guaranteed output (just use `index`).\nIf you want modular indexing for the mod, please use an actual container.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"Int"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[76,43],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1.purs","start":[76,1]},"title":"index1"},{"children":[],"comments":"Returns the first element.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[45,35],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1.purs","start":[45,1]},"title":"head1"},{"children":[],"comments":"Map each element of a `BoundedEnum` into a semigroup,\nand combine the results through `refold1`.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"b","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"a","tag":"TypeVar"}],"constraintClass":[["Data","Enum"],"BoundedEnum"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"b","tag":"TypeVar"}],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":"b","tag":"TypeVar"}],"tag":"TypeApp"},"tag":"ParensInType"}],"tag":"TypeApp"},{"annotation":[],"contents":"b","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"ConstrainedType"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[108,70],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1.purs","start":[108,1]},"title":"foldEnum"},{"children":[],"comments":null,"info":{"alias":[["Data","Unfoldable1","Trivial1","Internal"],{"Right":{"Left":{"Ident":"turbofish1"}}}],"declType":"alias","fixity":{"associativity":"infixr","precedence":0}},"kind":null,"sourceSpan":{"end":[61,29],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1/Internal.purs","start":[61,1]},"title":"(::<+>)"}],"moduleName":{"item":["Data","Unfoldable1","Trivial1"],"package":null}}]},{"comments":"This module provides the `Trivial` type as an existentially quantified\ndumb wrapper around `unfold`, which can be inspected and manipulated\nto implement various typeclasses and the utilities in Data.Unfoldable.Trivial.\n\nThis module also contains the implementations of utilities which rely on directly\ninspecting `Trivial` values and are re-exported by Data.Unfoldable.Trivial.\nUse this module directly only if you intend to directly inspect `Trivial` values yourself.\n","declarations":[{"children":[{"comments":"Wraps both arguments to `unfoldr` in an `UnfoldrCall`.\n","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable"],"Unfoldable"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Data","Unfoldable","Trivial","Internal"],"Trivial"],"tag":"TypeConstructor"}],"tag":"TypeApp"}},"sourceSpan":{"end":[66,59],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable/Trivial/Internal.purs","start":[65,1]},"title":"trivialUnfoldable"},{"comments":null,"info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1"],"Unfoldable1"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Data","Unfoldable","Trivial","Internal"],"Trivial"],"tag":"TypeConstructor"}],"tag":"TypeApp"}},"sourceSpan":{"end":[69,29],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable/Trivial/Internal.purs","start":[68,1]},"title":"trivialUnfoldable1"},{"comments":null,"info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Functor"],"Functor"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Data","Unfoldable","Trivial","Internal"],"Trivial"],"tag":"TypeConstructor"}],"tag":"TypeApp"}},"sourceSpan":{"end":[79,31],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable/Trivial/Internal.purs","start":[71,1]},"title":"trivialFunctor"},{"comments":"The *raison d'Ãªtre* for `Trivial`.\nAllows folding polymorphic `Unfoldable`s as they generate.\n\n`foldr` uses a default implementation and may be inefficient.\n","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Foldable"],"Foldable"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Data","Unfoldable","Trivial","Internal"],"Trivial"],"tag":"TypeConstructor"}],"tag":"TypeApp"}},"sourceSpan":{"end":[111,32],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable/Trivial/Internal.purs","start":[100,1]},"title":"trivialFoldable"},{"comments":"Guaranteed finite.\n","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"a","tag":"TypeVar"}],"constraintClass":[["Test","QuickCheck","Arbitrary"],"Arbitrary"],"constraintData":null,"constraintKindArgs":[]},{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"a","tag":"TypeVar"}],"constraintClass":[["Test","QuickCheck","Arbitrary"],"Coarbitrary"],"constraintData":null,"constraintKindArgs":[]}],"type":{"annotation":[],"contents":[{"annotation":[],"contents":[["Test","QuickCheck","Arbitrary"],"Arbitrary"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable","Trivial","Internal"],"Trivial"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"}},"sourceSpan":{"end":[122,18],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable/Trivial/Internal.purs","start":[114,1]},"title":"trivialArbitrary"}],"comments":"A type wrapping `unfoldr` calls, existentially quantified over the seed type\nso that it can be ignored in the type constructor. Its `Unfoldable` instance\nmeans that it can directly be constructed by calling `unfoldr`.\n","info":{"dataDeclType":"newtype","declType":"data","roles":["Representational"],"typeArguments":[["a",null]]},"kind":null,"sourceSpan":{"end":[43,53],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable/Trivial/Internal.purs","start":[43,1]},"title":"Trivial"},{"children":[],"comments":"Alias for the generator function passed to `unfoldr`.\n","info":{"arguments":[["a",null],["b",null]],"declType":"typeSynonym","type":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"b","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Maybe"],"Maybe"],"tag":"TypeConstructor"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Tuple","Nested"],"/\\"],"tag":"TypeOp"},{"annotation":[],"contents":"a","tag":"TypeVar"},{"annotation":[],"contents":"b","tag":"TypeVar"}],"tag":"BinaryNoParensType"},"tag":"ParensInType"}],"tag":"TypeApp"}],"tag":"TypeApp"}},"kind":null,"sourceSpan":{"end":[33,41],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable/Trivial/Internal.purs","start":[33,1]},"title":"Generator"},{"children":[],"comments":"Specializes its argument to `Trivial`.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable","Trivial","Internal"],"Trivial"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable","Trivial","Internal"],"Trivial"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[46,44],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable/Trivial/Internal.purs","start":[46,1]},"title":"trivial"},{"children":[],"comments":"Convenience function for inspecting `Trivial` values.\nCalls the function argument on the contents of the inner `Exists`.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"c","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":{"annotation":[],"contents":{"identifier":"b","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable","Trivial","Internal"],"Generator"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":"b","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"b","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":"c","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"tag":"ParensInType"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable","Trivial","Internal"],"Trivial"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":"c","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[61,79],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable/Trivial/Internal.purs","start":[61,1]},"title":"untrivial"},{"children":[],"comments":"Function application specialized to a `Trivial` argument,\nat the same precedence as `($)`.\n\nInspired by the Rust syntax of the same name, often used in the\nanalogous context of collecting from an iterator.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"b","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable","Trivial","Internal"],"Trivial"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":"b","tag":"TypeVar"}],"tag":"TypeApp"},"tag":"ParensInType"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable","Trivial","Internal"],"Trivial"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":"b","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[54,60],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable/Trivial/Internal.purs","start":[54,1]},"title":"turbofish"},{"children":[],"comments":null,"info":{"alias":[["Data","Unfoldable","Trivial","Internal"],{"Right":{"Left":{"Ident":"turbofish"}}}],"declType":"alias","fixity":{"associativity":"infixr","precedence":0}},"kind":null,"sourceSpan":{"end":[57,28],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable/Trivial/Internal.purs","start":[57,1]},"title":"(::<*>)"},{"children":[],"comments":"Provides a default implementation of `unfoldr1` using `unfoldr` to satisfy\nthe superclass bound on `Unfoldable`.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"b","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"t","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"t","tag":"TypeVar"}],"constraintClass":[["Data","Unfoldable"],"Unfoldable"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"b","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Tuple","Nested"],"/\\"],"tag":"TypeOp"},{"annotation":[],"contents":"a","tag":"TypeVar"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Maybe"],"Maybe"],"tag":"TypeConstructor"},{"annotation":[],"contents":"b","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"BinaryNoParensType"}],"tag":"TypeApp"},"tag":"ParensInType"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"b","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":"t","tag":"TypeVar"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[83,81],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable/Trivial/Internal.purs","start":[83,1]},"title":"unfoldr1Default"},{"children":[],"comments":"Converts to any other `Unfoldable`.\nCan also be seen as evaluating the inner `UnfoldrCall`.\n\nThis is only useful in implementing utility functions.\nIn all other cases, simply use the desired type directly.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"u","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"u","tag":"TypeVar"}],"constraintClass":[["Data","Unfoldable"],"Unfoldable"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable","Trivial","Internal"],"Trivial"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":"u","tag":"TypeVar"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[91,59],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable/Trivial/Internal.purs","start":[91,1]},"title":"runTrivial"}],"name":"Data.Unfoldable.Trivial.Internal","reExports":[]},{"comments":"This module provides various adapters and other such utilities\nfor `Unfoldable1`.\n","declarations":[{"children":[],"comments":"`foldl1` specialized to `Trivial1`. \"Re-fold\" a polymorphic `Unfoldable1`.\nUsually cleaner and more convenient than `turbofish`, when applicable.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},"tag":"ParensInType"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[88,55],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1.purs","start":[88,1]},"title":"refoldl1"},{"children":[],"comments":"`foldr1` specialized to `Trivial1`. \"Re-fold\" a polymorphic `Unfoldable1`.\nUsually cleaner and more convenient than `turbofish`, when applicable.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},"tag":"ParensInType"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[93,55],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1.purs","start":[93,1]},"title":"refoldr1"},{"children":[],"comments":"`foldMap` specialized to `Trivial1`. \"Re-fold\" a polymorphic `Unfoldable1`.\nUsually cleaner and more convenient than `turbofish1`, when applicable.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"c","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"c","tag":"TypeVar"}],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":"c","tag":"TypeVar"}],"tag":"TypeApp"},"tag":"ParensInType"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":"c","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[98,69],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1.purs","start":[98,1]},"title":"refoldMap1"},{"children":[],"comments":"`fold` specialized to `Trivial1`. \"Re-fold\" a polymorphic `Unfoldable1`.\nUsually cleaner and more convenient than `turbofish1`, when applicable.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"a","tag":"TypeVar"}],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[103,52],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1.purs","start":[103,1]},"title":"refold1"},{"children":[],"comments":"Map each element of a `BoundedEnum` into a semigroup,\nand combine the results through `refold1`.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"b","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"a","tag":"TypeVar"}],"constraintClass":[["Data","Enum"],"BoundedEnum"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"b","tag":"TypeVar"}],"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":"b","tag":"TypeVar"}],"tag":"TypeApp"},"tag":"ParensInType"}],"tag":"TypeApp"},{"annotation":[],"contents":"b","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"ConstrainedType"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[108,70],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1.purs","start":[108,1]},"title":"foldEnum"},{"children":[],"comments":"Unfold an infinite `Unfoldable1`.\nAnalogous to `unfold1` and `unfold`, but with no way to signal termination;\n`unfoldInf f b` consists of `fst $ f b` appended to `unfoldInf f $ snd $ f b`.\n\nThis should only be used to produce either lazy types (like `Trivial`) or\ntypes with truncating `Unfoldable1` instances (like `Maybe`).\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"b","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"u","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"u","tag":"TypeVar"}],"constraintClass":[["Data","Unfoldable1"],"Unfoldable1"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"b","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Tuple","Nested"],"/\\"],"tag":"TypeOp"},{"annotation":[],"contents":"a","tag":"TypeVar"},{"annotation":[],"contents":"b","tag":"TypeVar"}],"tag":"BinaryNoParensType"}],"tag":"TypeApp"},"tag":"ParensInType"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"b","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":"u","tag":"TypeVar"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[117,71],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1.purs","start":[117,1]},"title":"unfoldrInf"},{"children":[],"comments":"Create an infinite `Unfoldable1` by repeated application of a function to a seed value. \nAnalogous to `iterateN`, but with no iteration limit.\n\nThis should only be used to produce either lazy types (like `Trivial`) or\ntypes with truncating `Unfoldable1` instances (like `Maybe`).\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"u","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"u","tag":"TypeVar"}],"constraintClass":[["Data","Unfoldable1"],"Unfoldable1"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"},"tag":"ParensInType"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":"u","tag":"TypeVar"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[125,61],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1.purs","start":[125,1]},"title":"iterate"},{"children":[],"comments":"Returns the first element.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[45,35],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1.purs","start":[45,1]},"title":"head1"},{"children":[],"comments":"Removes the first element.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"u","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"u","tag":"TypeVar"}],"constraintClass":[["Data","Unfoldable"],"Unfoldable"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":"u","tag":"TypeVar"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[51,55],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1.purs","start":[51,1]},"title":"tail1"},{"children":[],"comments":"Keep only a strictly positive number of elements from the start.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"u","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"u","tag":"TypeVar"}],"constraintClass":[["Data","Unfoldable1"],"Unfoldable1"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"Int"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":"u","tag":"TypeVar"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[55,63],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1.purs","start":[55,1]},"title":"take1"},{"children":[],"comments":"Get the element at the specified *modular* 0-index, i.e. the element\nat that 0-index in the elements infinitely extended left and right.\n\nWill loop infinitely if given an infinite `Unfoldable1` and a negative index.\nWill not loop infinitely if given an infinite `Unfoldable1` and a nonnegative index;\ncomputes the length for itself as it iterates. Iterates twice when resolving an out of\nbounds index; does not store any intermediate results. In general, this function is\nnot supposed to be *used for modular indexing*, because modular indexing just happens\nto be a simple and sensible way to guarantee an output, and there's no point in this\nexisting without a guaranteed output (just use `index`).\nIf you want modular indexing for the mod, please use an actual container.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"Int"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[76,43],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1.purs","start":[76,1]},"title":"index1"}],"name":"Data.Unfoldable1.Trivial1","reExports":[{"declarations":[{"children":[{"comments":"Wraps both arguments to `unfoldr1` in an `Unfoldr1Call`.\n","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1"],"Unfoldable1"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"}],"tag":"TypeApp"}},"sourceSpan":{"end":[70,62],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1/Internal.purs","start":[69,1]},"title":"trivial1Unfoldable1"},{"comments":null,"info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Functor"],"Functor"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"}],"tag":"TypeApp"}},"sourceSpan":{"end":[80,31],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1/Internal.purs","start":[72,1]},"title":"trivial1Functor"},{"comments":null,"info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Foldable"],"Foldable"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"}],"tag":"TypeApp"}},"sourceSpan":{"end":[109,32],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1/Internal.purs","start":[98,1]},"title":"trivial1Foldable"},{"comments":"The *raison d'Ãªtre* for `Trivial1`.\nAllows folding polymorphic `Unfoldable1`s as they generate\nwith no explicit starting value. In particular, `foldMap1`\nneeds map only into a `Semigroup` rather than a `Monoid`.\n\n`foldr1` uses a default implementation and may be inefficient.\n","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Semigroup","Foldable"],"Foldable1"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"}],"tag":"TypeApp"}},"sourceSpan":{"end":[124,34],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1/Internal.purs","start":[117,1]},"title":"trivial1Foldable1"},{"comments":"Guaranteed finite.\n","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"a","tag":"TypeVar"}],"constraintClass":[["Test","QuickCheck","Arbitrary"],"Arbitrary"],"constraintData":null,"constraintKindArgs":[]},{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"a","tag":"TypeVar"}],"constraintClass":[["Test","QuickCheck","Arbitrary"],"Coarbitrary"],"constraintData":null,"constraintKindArgs":[]}],"type":{"annotation":[],"contents":[{"annotation":[],"contents":[["Test","QuickCheck","Arbitrary"],"Arbitrary"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"}},"sourceSpan":{"end":[136,18],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1/Internal.purs","start":[127,1]},"title":"trivialArbitrary"}],"comments":"A type wrapping `unfoldr1` calls, existentially quantified over the seed type\nso that it can be ignored in the type constructor. Its `Unfoldable1` instance\nmeans that it can directly be constructed by calling `unfoldr1`.\n","info":{"dataDeclType":"newtype","declType":"data","roles":["Representational"],"typeArguments":[["a",null]]},"kind":null,"sourceSpan":{"end":[47,56],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1/Internal.purs","start":[47,1]},"title":"Trivial1"},{"children":[],"comments":"Returns the first element, and an `Unfoldable` of the remaining elements.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"u","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"u","tag":"TypeVar"}],"constraintClass":[["Data","Unfoldable"],"Unfoldable"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Tuple","Nested"],"/\\"],"tag":"TypeOp"},{"annotation":[],"contents":"a","tag":"TypeVar"},{"annotation":[],"contents":[{"annotation":[],"contents":"u","tag":"TypeVar"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"BinaryNoParensType"}],"tag":"TypeApp"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[93,62],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1/Internal.purs","start":[93,1]},"title":"uncons1"},{"children":[],"comments":"Function application specialized to a `Trivial1` argument,\nat the same precedence as `($)`.\n\nInspired by the Rust syntax of the same name, often used in the\nanalogous context of collecting from an iterator.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"b","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":"b","tag":"TypeVar"}],"tag":"TypeApp"},"tag":"ParensInType"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":"b","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[58,63],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1/Internal.purs","start":[58,1]},"title":"turbofish1"},{"children":[],"comments":"Specializes its argument to `Trivial1`.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[50,47],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1/Internal.purs","start":[50,1]},"title":"trivial1"},{"children":[],"comments":null,"info":{"alias":[["Data","Unfoldable1","Trivial1","Internal"],{"Right":{"Left":{"Ident":"turbofish1"}}}],"declType":"alias","fixity":{"associativity":"infixr","precedence":0}},"kind":null,"sourceSpan":{"end":[61,29],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1/Internal.purs","start":[61,1]},"title":"(::<+>)"}],"moduleName":{"item":["Data","Unfoldable1","Trivial1","Internal"],"package":null}}]},{"comments":"This module provides the `Trivial1` type as an existentially quantified\ndumb wrapper around `unfold1`, which can be inspected and manipulated\nto implement various typeclasses and the utilities in Data.Unfoldable1.Trivia1.\n\nThis module also contains the implementations of utilities which rely on directly\ninspecting `Trivial1` values and are re-exported by Data.Unfoldable.Trivial1.\nUse this module directly only if you intend to directly inspect `Trivial1` values yourself.\n","declarations":[{"children":[{"comments":"Wraps both arguments to `unfoldr1` in an `Unfoldr1Call`.\n","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1"],"Unfoldable1"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"}],"tag":"TypeApp"}},"sourceSpan":{"end":[70,62],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1/Internal.purs","start":[69,1]},"title":"trivial1Unfoldable1"},{"comments":null,"info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Functor"],"Functor"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"}],"tag":"TypeApp"}},"sourceSpan":{"end":[80,31],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1/Internal.purs","start":[72,1]},"title":"trivial1Functor"},{"comments":null,"info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Foldable"],"Foldable"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"}],"tag":"TypeApp"}},"sourceSpan":{"end":[109,32],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1/Internal.purs","start":[98,1]},"title":"trivial1Foldable"},{"comments":"The *raison d'Ãªtre* for `Trivial1`.\nAllows folding polymorphic `Unfoldable1`s as they generate\nwith no explicit starting value. In particular, `foldMap1`\nneeds map only into a `Semigroup` rather than a `Monoid`.\n\n`foldr1` uses a default implementation and may be inefficient.\n","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Semigroup","Foldable"],"Foldable1"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"}],"tag":"TypeApp"}},"sourceSpan":{"end":[124,34],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1/Internal.purs","start":[117,1]},"title":"trivial1Foldable1"},{"comments":"Guaranteed finite.\n","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"a","tag":"TypeVar"}],"constraintClass":[["Test","QuickCheck","Arbitrary"],"Arbitrary"],"constraintData":null,"constraintKindArgs":[]},{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"a","tag":"TypeVar"}],"constraintClass":[["Test","QuickCheck","Arbitrary"],"Coarbitrary"],"constraintData":null,"constraintKindArgs":[]}],"type":{"annotation":[],"contents":[{"annotation":[],"contents":[["Test","QuickCheck","Arbitrary"],"Arbitrary"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"}},"sourceSpan":{"end":[136,18],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1/Internal.purs","start":[127,1]},"title":"trivialArbitrary"}],"comments":"A type wrapping `unfoldr1` calls, existentially quantified over the seed type\nso that it can be ignored in the type constructor. Its `Unfoldable1` instance\nmeans that it can directly be constructed by calling `unfoldr1`.\n","info":{"dataDeclType":"newtype","declType":"data","roles":["Representational"],"typeArguments":[["a",null]]},"kind":null,"sourceSpan":{"end":[47,56],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1/Internal.purs","start":[47,1]},"title":"Trivial1"},{"children":[],"comments":"Alias for the generator function passed to `unfoldr1`.\n","info":{"arguments":[["a",null],["b",null]],"declType":"typeSynonym","type":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"b","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Tuple","Nested"],"/\\"],"tag":"TypeOp"},{"annotation":[],"contents":"a","tag":"TypeVar"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Maybe"],"Maybe"],"tag":"TypeConstructor"},{"annotation":[],"contents":"b","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"BinaryNoParensType"}],"tag":"TypeApp"}},"kind":null,"sourceSpan":{"end":[37,40],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1/Internal.purs","start":[37,1]},"title":"Generator1"},{"children":[],"comments":"Convenience function for inspecting `Trivial` values.\nCalls the function argument on the contents of the inner `Exists`.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"c","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":{"annotation":[],"contents":{"identifier":"b","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Generator1"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":"b","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"b","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":"c","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"tag":"ParensInType"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":"c","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[65,82],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1/Internal.purs","start":[65,1]},"title":"untrivial1"},{"children":[],"comments":"Specializes its argument to `Trivial1`.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[50,47],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1/Internal.purs","start":[50,1]},"title":"trivial1"},{"children":[],"comments":"Function application specialized to a `Trivial1` argument,\nat the same precedence as `($)`.\n\nInspired by the Rust syntax of the same name, often used in the\nanalogous context of collecting from an iterator.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"b","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":"b","tag":"TypeVar"}],"tag":"TypeApp"},"tag":"ParensInType"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":"b","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[58,63],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1/Internal.purs","start":[58,1]},"title":"turbofish1"},{"children":[],"comments":null,"info":{"alias":[["Data","Unfoldable1","Trivial1","Internal"],{"Right":{"Left":{"Ident":"turbofish1"}}}],"declType":"alias","fixity":{"associativity":"infixr","precedence":0}},"kind":null,"sourceSpan":{"end":[61,29],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1/Internal.purs","start":[61,1]},"title":"(::<+>)"},{"children":[],"comments":"Returns the first element, and an `Unfoldable` of the remaining elements.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"u","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"u","tag":"TypeVar"}],"constraintClass":[["Data","Unfoldable"],"Unfoldable"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Tuple","Nested"],"/\\"],"tag":"TypeOp"},{"annotation":[],"contents":"a","tag":"TypeVar"},{"annotation":[],"contents":[{"annotation":[],"contents":"u","tag":"TypeVar"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"BinaryNoParensType"}],"tag":"TypeApp"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[93,62],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1/Internal.purs","start":[93,1]},"title":"uncons1"},{"children":[],"comments":"Converts to any other `Unfoldable1`.\nCan also be seen as evaluating the inner `Unfoldr1Call`.\n\nThis is only useful in implementing utility functions.\nIn all other cases, simply use the desired type directly.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"u","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"u","tag":"TypeVar"}],"constraintClass":[["Data","Unfoldable1"],"Unfoldable1"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Unfoldable1","Trivial1","Internal"],"Trivial1"],"tag":"TypeConstructor"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":"u","tag":"TypeVar"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[87,62],"name":"/tmp/tmp-2802391-i1RJMVTMG5h6/purescript-trivial-unfold/src/Data/Unfoldable1/Trivial1/Internal.purs","start":[87,1]},"title":"runTrivial1"}],"name":"Data.Unfoldable1.Trivial1.Internal","reExports":[]}],"packageMeta":{"dependencies":{"purescript-bifunctors":">=6.0.0 <7.0.0","purescript-enums":">=6.0.1 <7.0.0","purescript-exists":">=6.0.0 <7.0.0","purescript-foldable-traversable":">=6.0.0 <7.0.0","purescript-maybe":">=6.0.0 <7.0.0","purescript-prelude":">=6.0.2 <7.0.0","purescript-quickcheck":">=8.0.1 <9.0.0","purescript-tuples":">=7.0.0 <8.0.0","purescript-unfoldable":">=6.0.0 <7.0.0"},"description":"Library providing transformers and adapters for Unfoldable.","homepage":"https://github.com/UnrelatedString/purescript-trivial-unfold.git","license":["BSD-3-Clause"],"name":"purescript-trivial-unfold","repository":{"type":"git","url":"https://github.com/UnrelatedString/purescript-trivial-unfold.git"}},"resolvedDependencies":{"purescript-arrays":"7.3.0","purescript-bifunctors":"6.0.0","purescript-console":"6.1.0","purescript-const":"6.0.0","purescript-contravariant":"6.0.0","purescript-control":"6.0.0","purescript-distributive":"6.0.0","purescript-effect":"4.0.0","purescript-either":"6.1.0","purescript-enums":"6.0.1","purescript-exceptions":"6.1.0","purescript-exists":"6.0.0","purescript-foldable-traversable":"6.0.0","purescript-functions":"6.0.0","purescript-functors":"5.0.0","purescript-gen":"4.0.0","purescript-identity":"6.0.0","purescript-integers":"6.0.0","purescript-invariant":"6.0.0","purescript-lazy":"6.0.0","purescript-lcg":"4.0.0","purescript-lists":"7.0.0","purescript-maybe":"6.0.0","purescript-newtype":"5.0.0","purescript-nonempty":"7.0.0","purescript-numbers":"9.0.1","purescript-orders":"6.0.0","purescript-partial":"4.0.0","purescript-prelude":"6.0.2","purescript-profunctor":"6.0.1","purescript-quickcheck":"8.0.1","purescript-random":"6.0.0","purescript-record":"4.0.0","purescript-refs":"6.0.0","purescript-safe-coerce":"2.0.0","purescript-st":"6.2.0","purescript-strings":"6.0.1","purescript-tailrec":"6.1.0","purescript-transformers":"6.1.0","purescript-tuples":"7.0.0","purescript-type-equality":"4.0.1","purescript-unfoldable":"6.0.0","purescript-unsafe-coerce":"6.0.0"},"tagTime":"2025-02-27T03:13:18+0000","uploader":"pacchettibotti","version":"0.2.1","versionTag":"v0.2.1"}